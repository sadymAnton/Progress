&НаСервере
Перем ОбработкаОбъект;

//-------------------------------------------------------------------------------------------------
//клиентские переменные ---------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Перем СоединениеДД;
  
&НаКлиенте
Перем мРабочийКаталог;

&НаКлиенте
Перем HttpКодыВозвратаAPI;

&НаКлиенте
Перем ХранилищеСертификатовКонтурСВ;

&НаКлиенте
Перем КэшСертификатов;

&НаКлиенте
Перем МенеджерКриптографии1С;

&НаКлиенте
Перем Токены;

//Вспомогательные-сервисные

&НаСервере
Функция МодульОбъекта()

	Если ОбработкаОбъект=Неопределено Тогда
		
		Если Параметры.КэшироватьМодульОбъекта Тогда
			Если Параметры.АдресХранилища<>"" Тогда
				_Структура = ПолучитьИзВременногоХранилища(Параметры.АдресХранилища);
				Если ТипЗнч(_Структура) = Тип("Структура") Тогда
					_Структура.Свойство("ОбработкаОбъект",ОбработкаОбъект);
				КонецЕсли;
			КонецЕсли;
			
			Если ОбработкаОбъект=Неопределено Тогда
				ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
				ОбработкаОбъект.ИнициализироватьПодключаемыеМодули();
				Параметры.АдресХранилища = ПоместитьВоВременноеХранилище(Новый Структура("ОбработкаОбъект",ОбработкаОбъект),УникальныйИдентификатор);
				ОбработкаОбъект.IDОсновнойФормы = Параметры.IDОсновнойФормы;
			КонецЕсли;
		Иначе
			ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
			ОбработкаОбъект.ИнициализироватьПодключаемыеМодули();
			ОбработкаОбъект.IDОсновнойФормы = Параметры.IDОсновнойФормы;
		КонецЕсли;
		
	КонецЕсли;	
	
	Возврат ОбработкаОбъект;
	
КонецФункции

&НаКлиенте
Процедура ОткрытьФормуОбъектаМодально(ИмяФормы, ПараметрыФормы = Неопределено, ИмяОбработчика = Неопределено, ПараметрыОбработчика = Неопределено, ВладелецОбработчика = Неопределено,РежимБлокирования = Неопределено)
	//отказ от модальности
	Если РежимБлокирования = Неопределено Тогда
		РежимБлокирования=	РежимОткрытияОкнаФормы.БлокироватьОкноВладельца;
	КонецЕсли;
	
	Если ПараметрыФормы=Неопределено Тогда
		ПараметрыФормы = Новый Структура;
	КонецЕсли;
	
	ПараметрыФормы.Вставить("АдресХранилища",			Параметры.АдресХранилища);
	ПараметрыФормы.Вставить("IDОсновнойФормы",			Параметры.IDОсновнойФормы);
	ПараметрыФормы.Вставить("КэшироватьМодульОбъекта",	Параметры.КэшироватьМодульОбъекта);
	
	Если ВладелецОбработчика = Неопределено Тогда
		ВладелецОбработчика=	ЭтаФорма;
	КонецЕсли;
	
	Если ИмяОбработчика = Неопределено Тогда
		ОписаниеОбработчика=	Неопределено;
	Иначе	
		Выполнить("ОписаниеОбработчика=	Новый ОписаниеОповещения(ИмяОбработчика, ВладелецОбработчика, ПараметрыОбработчика)");
	КонецЕсли;
	
	Выполнить("ОткрытьФорму(ИмяФормы, ПараметрыФормы, ВладелецОбработчика, , , ,  ОписаниеОбработчика, РежимБлокирования)");
	
КонецПроцедуры

&НаКлиенте
Функция ПолучитьФормуОбработки(ИмяФормы, ПараметрыФормы = Неопределено , ВладелецФормы  = Неопределено, КлючУникальности = Неопределено, ЗакрыватьПризакрытииВладельца = Ложь)
	
	Если ПараметрыФормы=Неопределено Тогда
		ПараметрыФормы = Новый Структура;
	КонецЕсли;
	
	Если ВладелецФормы = Неопределено Тогда
		ВладелецФормы =	ЭтаФорма;
	КонецЕсли;
	
	//дочерняя форма 1 и без параметров
	
	ПолучаемаяФорма=	ПолучитьФорму(ПутьКФормам+ИмяФормы
										, ПараметрыФормы
										, ВладелецФормы
										, КлючУникальности);
	
	Если НЕ ВладелецФормы = Неопределено Тогда
		ПолучаемаяФорма.ВладелецФормы=	ВладелецФормы;
	КонецЕсли;
	
	Возврат ПолучаемаяФорма;
	
КонецФункции

//Инициализация

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	Параметры.Свойство("ОбъектПараметрыКлиентСервер", Объект.ПараметрыКлиентСервер);
	
	ПутьКФормам = МодульОбъекта().Метаданные().ПолноеИмя() + ".Форма.";
	МодальностьЗапрещена = МодульОбъекта().МодальностьЗапрещена();
	ИспользоватьCapicom = (МодульОбъекта().ПолучитьКонстантуEDI("ИспользоватьCapicom") = Истина);
	
	ЗаполнитьТаблицуАвторизацииПоУмолчанию();
	
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	//Форма не предусмотрена для интерактивного показа пользователю
	Этаформа.Закрыть();
	
КонецПроцедуры

&НаКлиенте
Процедура ПодписатьПереданныеСообщения() Экспорт //переданные в ВХ 
	
	СформироватьСчетаФактурыНаПодписание();
	СброситьПроверкиДанныхАвторизации();
	СпроситьНедостающиеСертификатыДляПодписиИПодписатьСчетаФактуры();
	
КонецПроцедуры


// Для перехода на версию 4.03.019.01

&НаКлиенте
Процедура ПроставитьСрокДействияСертификатов() Экспорт

	МассивСертификатовДляОбновления = ПолучитьМассивСертификатовДляОбновленияСервер();
	
	Для каждого Сертификат Из МассивСертификатовДляОбновления Цикл
		РеквизитыСертификата = ПолучитьРеквизитыСертификата(Сертификат.Отпечаток);
		
		Если РеквизитыСертификата = Неопределено Тогда
			// Не смогли прочитать реквизиты, попробуем в другой раз
			Возврат;
		КонецЕсли;
		Сертификат.СертификатДействуетПо = РеквизитыСертификата.ОкончаниеПериодаДействия;
	КонецЦикла;
	
	СохранитьСрокДействияСертификатовСервер(МассивСертификатовДляОбновления);

КонецПроцедуры

&НаСервере
Функция ПолучитьМассивСертификатовДляОбновленияСервер()

	МассивСертификатовДляОбновления = Новый Массив;
	
	ВсеСохраненныеСертификаты = МодульОбъекта().ПолучитьТаблицуСохраненныхСертификатов();
	НайденныеСтроки = ВсеСохраненныеСертификаты.НайтиСтроки(Новый Структура("СертификатДействуетПо", Дата(1, 1, 1)));
	
	Для каждого Строка Из НайденныеСтроки Цикл
		
		СертификатСтруктура = Новый Структура("Ссылка, Отпечаток, СертификатДействуетПо", 
												Строка.Ссылка, 
												Строка.Отпечаток,
												Строка.СертификатДействуетПо);
		МассивСертификатовДляОбновления.Добавить(СертификатСтруктура);
	
	КонецЦикла;
	
	Возврат МассивСертификатовДляОбновления;

КонецФункции // ПолучитьМассивСертификатовДляСохраненияСервер()

&НаСервере
Процедура СохранитьСрокДействияСертификатовСервер(МассивСертификатовДляОбновления)

	Для каждого Сертификат Из МассивСертификатовДляОбновления Цикл
	
		МодульОбъекта().ЗаписатьДопРеквизитСправочника_КонтурEDI(Сертификат.Ссылка, "СертификатДействуетПо", Сертификат.СертификатДействуетПо);
	
	КонецЦикла;

	МодульОбъекта().УстановитьКонстантуEDI("СрокДействияСертификатовПроставлен", Истина);

КонецПроцедуры

// Для перехода на версию 4.03.019.01


//Вспомогательные
&НаСервере
Процедура СформироватьСчетаФактурыНаПодписание()
	
	//соберем идентификаторы СФ которые будем подписывать
	СчетаФактурыНаПодписание.Загрузить(МодульОбъекта().ПолучитьТаблицуСчетовФактурНаПодписание(МодульОбъекта().ИзвлечьИзВХ("МассивСообщений")));
	ЗаполнитьТаблицуАвторизацииПоУмолчанию();

КонецПроцедуры

&НаКлиенте
Процедура СпроситьНедостающиеСертификатыДляПодписиИПодписатьСчетаФактуры() //возможен неоднократный вызов для простановки сертифткатов
	
	ТекОрганизация = Неопределено;

	Для Каждого СтрокаСЧФ Из СчетаФактурыНаПодписание Цикл // СчетаФактурыНаПодписание отсортированы по Организации в методе ПолучитьТаблицуСчетовФактурНаПодписание
		
		Если ТекОрганизация <> СтрокаСЧФ.Организация Тогда
			
			ТекОрганизация = СтрокаСЧФ.Организация;
			ИнициализироватьДанныеАвторизации(ТекОрганизация);
			ОбновитьДанныеАвторизации("ТипАвторизации", "Сертификат"); 
			
			Если ПропускСертификатаПоОрганизации(ТекОрганизация) Тогда
				// по какой-то причине не удалось выбрать сертификат или не прошли проверку с сертификатом
				Продолжить; 
			КонецЕсли;
			
			Если НЕ МожемПодписатьДокументыСертификатом(ТекОрганизация, ДанныеАвторизации, "СпроситьНедостающиеСертификатыДляПодписиИПодписатьСчетаФактуры()") Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
	// Все сертификаты выбраны (или не выбраны, если пользователь отказался выбирать)
	
	ПодписатьСчетаФактуры();
	СброситьПарольКонтейнераДанныхАвторизации();
	Состояние("Обновление статусов...");
	УстановитьНовыеИдентификаторыСчетовФактурИТребуемоеДействие();

КонецПроцедуры

&НаКлиенте
Функция МожемПодписатьДокументыСертификатом(Организация, ДанныеАвторизации, ФинальныйОбработчик)
	
	Если НЕ СертификатПоОрганизацииНазначен(Организация) Тогда 
		
		ПараметрыФормы = Новый Структура;
		ПараметрыФормы.Вставить("ОбъектПараметрыКлиентСервер", Объект.ПараметрыКлиентСервер);
		ПараметрыФормы.Вставить("Организация", Организация);
		ПараметрыФормы.Вставить("ПоказыватьФлагЗапомнитьВыбор", Истина);
		
		ДопПараметры = Новый Структура;
		ДопПараметры.Вставить("Действие", 				"ВыборСертификата");
		ДопПараметры.Вставить("Организация", 			Организация);
		ДопПараметры.Вставить("Отпечаток",   			"");
		ДопПараметры.Вставить("СертификатДействуетПо",  Дата(1, 1, 1));
		ДопПараметры.Вставить("ЗапомнитьВыбор", 		Ложь);
		ДопПараметры.Вставить("НомерПопытки", 			1);
		ДопПараметры.Вставить("Успешно", 				Ложь);
		ДопПараметры.Вставить("ОписаниеОшибки", 		"");
		ДопПараметры.Вставить("ФинальныйОбработчик", 	ФинальныйОбработчик);
		
		Если МодальностьЗапрещена Тогда 
			Выполнить("ОткрытьФормуОбъектаМодально(ПутьКФормам+""Сертификаты_СписокУправляемая"",ПараметрыФормы,""ОбработчикВыбораСертификата"",ДопПараметры,ЭтаФорма)");
		Иначе
			ВыбранноеЗначение = ПолучитьФормуОбработки("Сертификаты_СписокУправляемая", ПараметрыФормы, ЭтаФорма).ОткрытьМодально();
			ОбработчикВыбораСертификата(ВыбранноеЗначение, ДопПараметры);
		КонецЕсли;
		
		Возврат Ложь; //не готовы подписывать, сначала надо выбрать сертификат
		
	ИначеЕсли ДанныеАвторизации.СертификатПроверен = Ложь Тогда
		
		ДопПараметры = Новый Структура;
		ДопПараметры.Вставить("Действие",	 			"ПроверкаПодписания");
		ДопПараметры.Вставить("Организация", 			ДанныеАвторизации.Организация);
		ДопПараметры.Вставить("Отпечаток",   			ДанныеАвторизации.Отпечаток);
		ДопПараметры.Вставить("СертификатДействуетПо",  ДанныеАвторизации.СертификатДействуетПо);
		ДопПараметры.Вставить("ЗапомнитьВыбор", 		Ложь);
		ДопПараметры.Вставить("НомерПопытки", 			1);
		ДопПараметры.Вставить("Успешно", 				Ложь);
		ДопПараметры.Вставить("ОписаниеОшибки", 		"");
		ДопПараметры.Вставить("ФинальныйОбработчик", 	ФинальныйОбработчик);
		
		ОбработчикВыбораСертификата(ДанныеАвторизации.ПарольКонтейнера, ДопПараметры);
		
		Возврат Ложь; //не готовы подписывать, сначала надо проверить сертификат
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

&НаКлиенте
Процедура ОбработчикВыбораСертификата(ВыбранноеЗначение, ДопПараметры) Экспорт
	
	Если ДопПараметры.Действие = "ВыборСертификата" Тогда
		
		Если ВыбранноеЗначение = Неопределено Тогда
		
			// пользователь отказался от выбора сертификата
			ОбновитьДанныеАвторизации("СертификатПроверен", 			Истина);
			ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", 	Ложь);
			ДопПараметры.Вставить("ОписаниеОшибки", "Выбор сертификата отменен");
			ВыполнитьКомандуФинальногоОбработчикаВыбораСертификата(ДопПараметры.ФинальныйОбработчик, ДопПараметры);
			
		Иначе
			ИнициализироватьДанныеАвторизации(ВыбранноеЗначение.Организация);
			ОбновитьДанныеАвторизации("ТипАвторизации", "Сертификат"); 
			
			ДопПараметры.Вставить("Действие",				"ПроверкаПодписания");
			ДопПараметры.Вставить("Организация",  			ВыбранноеЗначение.Организация);
			ДопПараметры.Вставить("Отпечаток",  			ВыбранноеЗначение.Отпечаток);
			ДопПараметры.Вставить("СертификатДействуетПо",  ВыбранноеЗначение.СертификатДействуетПо);
			ДопПараметры.Вставить("ЗапомнитьВыбор", 		ВыбранноеЗначение.ЗапомнитьВыбор);
			ДопПараметры.Вставить("НомерПопытки", 			1);
			ДопПараметры.Вставить("Успешно", 				Ложь);
			ДопПараметры.Вставить("ОписаниеОшибки", 		"");
			ДопПараметры.Вставить("РеквизитыСертификата", 	ВыбранноеЗначение.РеквизитыСертификата);
		
			ОбработчикВыбораСертификата(ДанныеАвторизации.ПарольКонтейнера, ДопПараметры);
			
			Возврат;
			
		КонецЕсли;
		
	ИначеЕсли ДопПараметры.Действие = "ПроверкаПодписания" Тогда
		
		Если ВыбранноеЗначение = Неопределено Тогда
			
			// пользователь отказался от выбора сертификата
			ОбновитьДанныеАвторизации("СертификатПроверен", 			Истина);
			ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", 	Ложь);
			ДопПараметры.Вставить("ОписаниеОшибки", "Ввод пароля отменен");
			ВыполнитьКомандуФинальногоОбработчикаВыбораСертификата(ДопПараметры.ФинальныйОбработчик, ДопПараметры);
			
		Иначе
			
			ОбработчикПроверкиПодписанияСертификатом(ВыбранноеЗначение, ДопПараметры);
			
			Возврат;
			
		КонецЕсли;
		
	ИначеЕсли ДопПараметры.Действие = "ПовторныйВыборСертификата" Тогда
		
		// выбор сертификата завершился ошибкой, предложим выбрать еще раз
		ПараметрыФормы = Новый Структура;
		ПараметрыФормы.Вставить("ОбъектПараметрыКлиентСервер", 	Объект.ПараметрыКлиентСервер);
		ПараметрыФормы.Вставить("Организация", 					ДопПараметры.Организация);
		Если Найти(ДопПараметры.ФинальныйОбработчик, "СпроситьНедостающиеСертификатыДляПодписиИПодписатьСчетаФактуры()") > 0 Тогда
			ПараметрыФормы.Вставить("ПоказыватьФлагЗапомнитьВыбор", Истина);
		КонецЕсли;
		
		ДопПараметры.Вставить("Действие", 				"ВыборСертификата");
		ДопПараметры.Вставить("НомерПопытки", 			1);
		
		Если МодальностьЗапрещена Тогда 
			Выполнить("ОткрытьФормуОбъектаМодально(ПутьКФормам+""Сертификаты_СписокУправляемая"",ПараметрыФормы,""ОбработчикВыбораСертификата"",ДопПараметры,ЭтаФорма)");
		Иначе
			ВыбранноеЗначение = ПолучитьФормуОбработки("Сертификаты_СписокУправляемая",ПараметрыФормы,ЭтаФорма).ОткрытьМодально();
			ОбработчикВыбораСертификата(ВыбранноеЗначение, ДопПараметры);
		КонецЕсли;
		
		Возврат;

	ИначеЕсли ДопПараметры.Действие = "ЗавершениеПроверки" Тогда
		
		ВыполнитьКомандуФинальногоОбработчикаВыбораСертификата(ДопПараметры.ФинальныйОбработчик, ДопПараметры);
		
	КонецЕсли;
		
КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьКомандуФинальногоОбработчикаВыбораСертификата(ТекстКоманды, ДопПараметры)
	
	Если Найти(ТекстКоманды, "Оповестить_") > 0 Тогда
		ИмяСобытия = Сред(ТекстКоманды, 12);
		Оповестить(ИмяСобытия, ДопПараметры);
	Иначе
		Если ДопПараметры.Успешно = Ложь Тогда
			Сообщить(ДопПараметры.ОписаниеОшибки);
		КонецЕсли;
		
		Выполнить(ТекстКоманды);
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура СохранитьСертификатПоУмолчаниюСервер(Организация, Отпечаток, СертификатДействуетПо)

	МодульОбъекта().СохранитьСертификатПоУмолчанию(Организация, Отпечаток, СертификатДействуетПо);
	
КонецПроцедуры 

&НаКлиенте
Процедура ОбработчикПроверкиПодписанияСертификатом(ВыбранноеЗначение, ДопПараметры) Экспорт
	
	Состояние("Проверка сертификата...");

	ПарольКонтейнера = "";
	СохранитьПароль = Ложь;
	
	Если ТипЗнч(ВыбранноеЗначение) = Тип("Структура") Тогда
		ПарольКонтейнера = ВыбранноеЗначение.ПолеВвода;
		СохранитьПароль = ВыбранноеЗначение.Флаг;
	ИначеЕсли ТипЗнч(ВыбранноеЗначение) = Тип("Строка") Тогда
		ПарольКонтейнера = ВыбранноеЗначение;
	КонецЕсли;
		
	РезультатПроверки = ПроверитьВыбранныйСертификат(ДопПараметры.Организация, ДопПараметры.Отпечаток, ПарольКонтейнера);
	
	Если НЕ ИспользоватьCapicom
		И РезультатПроверки.Успешно = Ложь
		И ОшибкаНеправильныйПарольКонтейнера(РезультатПроверки.ОписаниеОшибки)
		И ДопПараметры.НомерПопытки = 1 Тогда
		
		ПарольКонтейнера = ПолучитьПарольКонтейнераСертификатаСервер(ДопПараметры.Организация, ДопПараметры.Отпечаток);
		РезультатПроверки = ПроверитьВыбранныйСертификат(ДопПараметры.Организация, ДопПараметры.Отпечаток, ПарольКонтейнера);
		
	КонецЕсли;
		
	ОбновитьДанныеАвторизации("СертификатПроверен", Истина);
	
	Если РезультатПроверки.Успешно = Истина Тогда
		
		ДопПараметры.Успешно = Истина;
		ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", 	Истина);
		ОбновитьДанныеАвторизации("ПарольКонтейнера", 				ПарольКонтейнера);
		
		Если Не ЗначениеЗаполнено(ДанныеАвторизации.Отпечаток) Тогда
			// могли только что выбрать сертификат через форму
			ОбновитьДанныеАвторизации("Отпечаток", 				ДопПараметры.Отпечаток); 
			ОбновитьДанныеАвторизации("СертификатДействуетПо", 	ДопПараметры.СертификатДействуетПо);
		КонецЕсли;
		
		Если ДопПараметры.ЗапомнитьВыбор = Истина Тогда
			СохранитьСертификатПоУмолчаниюСервер(ДопПараметры.Организация, 
													ДопПараметры.Отпечаток, 
													ДопПараметры.СертификатДействуетПо);
		КонецЕсли;
		
		Если СохранитьПароль = Истина Тогда
			СохранитьПарольКонтейнераСертификатаСервер(ДопПараметры.Организация, 
														ДопПараметры.Отпечаток, 
														ДопПараметры.СертификатДействуетПо, 
														ПарольКонтейнера);
		КонецЕсли;											
		
	Иначе
		
		ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Ложь);
		ДопПараметры.ОписаниеОшибки = РезультатПроверки.ОписаниеОшибки;
		
		Если ЗначениеЗаполнено(ДопПараметры.СертификатДействуетПо) 
			И КонецДня(ДопПараметры.СертификатДействуетПо) < ТекущаяДата() Тогда
			ДопПараметры.ОписаниеОшибки = "Истек срок действия сертификата." + Символы.ПС + ДопПараметры.ОписаниеОшибки;				
		КонецЕсли;
		
		Если НЕ ИспользоватьCapicom
			И ОшибкаНеправильныйПарольКонтейнера(РезультатПроверки.ОписаниеОшибки) Тогда
			СпроситьПарольКонтейнера(ДопПараметры);
			Возврат;
		КонецЕсли;
	
	КонецЕсли;
	
	Если РезультатПроверки.Успешно = Ложь
		И Не СертификатПоОрганизацииНазначен(ДопПараметры.Организация) Тогда
		ДопПараметры.Вставить("Действие",	"ПовторныйВыборСертификата");
		Сообщить(ДопПараметры.ОписаниеОшибки);
	Иначе
		ДопПараметры.Вставить("Действие",	"ЗавершениеПроверки");
	КонецЕсли;
	
	ОбработчикВыбораСертификата(ВыбранноеЗначение, ДопПараметры);
	
КонецПроцедуры

&НаКлиенте
Функция ОшибкаНеправильныйПарольКонтейнера(ОписаниеОшибки = "")

	Если Найти(ОписаниеОшибки, "неправильный пароль доступа к закрытому ключу") > 0 Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;

КонецФункции // ОшибкаНеправильныйПарольКонтейнера()

&НаКлиенте
Функция ПолучитьТекстСообщенияДляВопросаОПароле(Отпечаток)

	РеквизитыСертификата = ПолучитьРеквизитыСертификата(Отпечаток);
	
	// Подготовка заголовка и текста вопроса
	НаименованиеОрганизации = "";
	Если ЗначениеЗаполнено(РеквизитыСертификата.НаименованиеОрганизацииСубъекта) Тогда
		НаименованиеОрганизации = РеквизитыСертификата.НаименованиеОрганизацииСубъекта;
	ИначеЕсли ЗначениеЗаполнено(РеквизитыСертификата.НаименованиеСубъекта) Тогда
		НаименованиеОрганизации = РеквизитыСертификата.НаименованиеСубъекта;
	Иначе
		НаименованиеОрганизации = "<Не указано>";
	КонецЕсли;
	
	НаименованиеСубъекта = "";
	НаименованиеСубъекта = РеквизитыСертификата.НаименованиеСубъекта;
	Если НаименованиеСубъекта = НаименованиеОрганизации Тогда
		НаименованиеСубъекта = "";
	КонецЕсли;
	ОкончаниеПериодаДействия = Формат(РеквизитыСертификата.ОкончаниеПериодаДействия, "ДЛФ=Д");
	
	ТекстСообщения1 = НаименованиеОрганизации + Символы.ПС + ?(НаименованиеСубъекта = "", "", НаименованиеСубъекта + Символы.ПС ) 
						+ "Годен до " + ОкончаниеПериодаДействия;
						
	Возврат ТекстСообщения1;

КонецФункции // ()

&НаКлиенте
Процедура СпроситьПарольКонтейнера(ДопПараметры)
	
	// Подготовка параметров для заполнения универсальной формы ввода
	ПроизвольныеПараметры = Новый Структура;
	ПроизвольныеПараметры.Вставить("ТекстСообщения1", 		ПолучитьТекстСообщенияДляВопросаОПароле(ДопПараметры.Отпечаток));
	ПроизвольныеПараметры.Вставить("ЗаголовокФормы", 		"Введите пароль");
	ПроизвольныеПараметры.Вставить("ФлагЗаголовок",			"Запомнить пароль");
	ПроизвольныеПараметры.Вставить("ФлагВидимость", 		Истина);
	ПроизвольныеПараметры.Вставить("ТекстСообщения1Цвет", 	Неопределено);
	ПроизвольныеПараметры.Вставить("ПолеВводаРежимПароля", 	Истина);
	
	Если ДопПараметры.НомерПопытки > 1 Тогда
		ТекстСообщения2 = "Неправильный пароль";
		ПроизвольныеПараметры.Вставить("ТекстСообщения2", 		ТекстСообщения2);
		ПроизвольныеПараметры.Вставить("ТекстСообщения2Цвет", 	WebЦвета.Красный);
	КонецЕсли;
	
	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("ПроизвольныеПараметры", ПроизвольныеПараметры);
	
	ДопПараметры.НомерПопытки = ДопПараметры.НомерПопытки + 1;
	
	Если Объект.ПараметрыКлиентСервер.МодальностьЗапрещена Тогда 
		Выполнить("ОткрытьФормуОбъектаМодально(ПутьКФормам+""УниверсальнаяФормаВводаУправляемая"",ПараметрыФормы,""ОбработчикВыбораСертификата"",ДопПараметры,ЭтаФорма)");
	Иначе
		ВыбранноеЗначение = ПолучитьФормуОбработки("УниверсальнаяФормаВводаУправляемая",ПараметрыФормы,ЭтаФорма).ОткрытьМодально();
		ОбработчикВыбораСертификата(ВыбранноеЗначение, ДопПараметры);
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Функция СертификатПоОрганизацииНазначен(Организация)

	Если ТаблицаАвторизации.Количество() = 0 Тогда 
		ЗаполнитьТаблицуАвторизацииПоУмолчанию();
	КонецЕсли;
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1
		И ЗначениеЗаполнено(НайденныеСТроки[0].Отпечаток) Тогда 
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
		
КонецФункции

&НаКлиенте
Функция ПолучитьНазначенныйОрганизацииСертификат(Организация)
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1
		И ЗначениеЗаполнено(НайденныеСтроки[0].Отпечаток) Тогда 
		Возврат НайденныеСтроки[0].Отпечаток;
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Процедура ИнициализироватьДанныеАвторизации(Организация)
	
	ДанныеАвторизации = Новый Структура;
	ДанныеАвторизации.Вставить("Организация", 						Неопределено);
	ДанныеАвторизации.Вставить("Отпечаток", 						"");
	ДанныеАвторизации.Вставить("ЛогинДД", 							"");
	ДанныеАвторизации.Вставить("ПарольДД", 							"");
	ДанныеАвторизации.Вставить("ЛогинПарольДДПроверен", 			Ложь);
	ДанныеАвторизации.Вставить("СертификатПроверен", 				Ложь);
	ДанныеАвторизации.Вставить("СертификатДействуетПо", 			Дата(1, 1, 1));
	ДанныеАвторизации.Вставить("ВалидацияЛогинаПароляДДПройдена", 	Ложь);
	ДанныеАвторизации.Вставить("ВалидацияСертификатаПройдена", 		Ложь);
	ДанныеАвторизации.Вставить("ПарольКонтейнера", 					"");
	ДанныеАвторизации.Вставить("ТипАвторизации", 					"");
	
	Если ТаблицаАвторизации.Количество() = 0 Тогда 
		ЗаполнитьТаблицуАвторизацииПоУмолчанию();
	КонецЕсли;
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1  Тогда
		ЗаполнитьЗначенияСвойств(ДанныеАвторизации, НайденныеСтроки[0]);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ОбновитьДанныеАвторизации(Ключ, Значение)
	
	Если ДанныеАвторизации = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// Обновим данные в структуре ДанныеАвторизации на форме
	ДанныеАвторизации[Ключ] = Значение;
	
	// Обновим данные в таблице ТаблицаАвторизации на форме
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация", ДанныеАвторизации.Организация));
	Если НайденныеСтроки.Количество() = 1 Тогда
		ЗаполнитьЗначенияСвойств(НайденныеСтроки[0], ДанныеАвторизации);
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Функция ПропускСертификатаПоОрганизации(Организация)
	
	Если НЕ ЗначениеЗаполнено(Организация) Тогда
		// не знаем данные авторизации
		Возврат Истина;
	КонецЕсли;
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1
		И НайденныеСтроки[0].СертификатПроверен = Истина
		И (НайденныеСтроки[0].ВалидацияСертификатаПройдена = Ложь 
		ИЛИ (ЗначениеЗаполнено(НайденныеСтроки[0].СертификатДействуетПо)
		И КонецДня(НайденныеСтроки[0].СертификатДействуетПо) < ТекущаяДата())) Тогда 
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ПропускЛогинаПароляДДПоОрганизации(Организация)
	
	НайденныеСтроки = ТаблицаАвторизации.НайтиСтроки(Новый Структура("Организация",Организация));
	Если НайденныеСтроки.Количество() = 1
		И НайденныеСтроки[0].ЛогинПарольДДПроверен = Истина
		И НайденныеСтроки[0].ВалидацияЛогинаПароляДДПройдена = Ложь Тогда 
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

&НаСервере
Процедура ЗаполнитьТаблицуАвторизацииПоУмолчанию() //выбранные в качестве умолчаний
	
	ТаблицаАвторизации.Очистить();
	
	СертификатыПоУмолчанию = МодульОбъекта().ПолучитьТаблицуСохраненныхСертификатов(, Истина);
	// Пока нет хранения логина пароля ДД в разрезе организации 
	// обойдем и заполним все строки ТаблицаАвторизации одинаковыми значениями
	СтруктураЛогинПарольДД = МодульОбъекта().ПолучитьСписокСвойствEDI("ЛогинСлужебныйДиадок,ПарольСлужебныйДиадок");
	
	Для Каждого СертПоУмолчанию Из СертификатыПоУмолчанию Цикл
		НоваяСтрока = ТаблицаАвторизации.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СертПоУмолчанию);
		
		НоваяСтрока.ЛогинДД 	= СтруктураЛогинПарольДД.ЛогинСлужебныйДиадок;
		НоваяСтрока.ПарольДД 	= СтруктураЛогинПарольДД.ПарольСлужебныйДиадок;
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Процедура УстановитьНовыеИдентификаторыСчетовФактурИТребуемоеДействие()
	//В общем случае будут присутствовать не все идентификаторы
	//Могут быть БезНДС ники, у них есть только ТОРГ12.
	//Может быть УПД.
	
	СменитьСтатусСообщенияНаПодписанВДиадок=Ложь;
	
	Для каждого ПодписаннаяСчетФактура Из СчетаФактурыНаПодписание Цикл
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.messageId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ,"messageId",ПодписаннаяСчетФактура.messageId_new);	
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.torg12Id_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ,"torg12Id",ПодписаннаяСчетФактура.torg12Id_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок=Истина;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.invoiceId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ,"invoiceId",ПодписаннаяСчетФактура.invoiceId_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок=Истина;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПодписаннаяСчетФактура.UniversalTransferDocumentId_new) Тогда 
			МодульОбъекта().УстановитьЗначениеСвойстваОбъекта(ПодписаннаяСчетФактура.Ссылка.Документ,"UniversalTransferDocumentId",ПодписаннаяСчетФактура.UniversalTransferDocumentId_new);	
			СменитьСтатусСообщенияНаПодписанВДиадок=Истина;
		КонецЕсли;
		
		Если СменитьСтатусСообщенияНаПодписанВДиадок Тогда 
			МодульОбъекта().УстановитьСтатусСообщения(ПодписаннаяСчетФактура.Ссылка,  , "INVOIC", "ИсходящийПодписанВДиадок");
			МодульОбъекта().ЗаписатьДопРеквизитСправочника_КонтурEDI(ПодписаннаяСчетФактура.Ссылка, "InvoiceReceiptEntityId_OnInvoiceConfirmation");
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьНовыеИдентификаторыСчетовФактур()

//Прикладные

&НаКлиенте
Функция ПроверитьВыбранныйСертификат(Организация, Отпечаток, ПарольКонтейнера = "")
	
	// Проверим, что можем подписать файл выбранным сертификатом
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	Если Не ЗначениеЗаполнено(Отпечаток) Тогда
		Возврат Результат;
	КонецЕсли;
	
	ИмяФайлаДляТеста = ПолучитьИмяВременногоФайла();
	ТестовыйФайл = Новый ТекстовыйДокумент;
	ТестовыйФайл.Записать(ИмяФайлаДляТеста);
	
	РезультатПодписания = ПолучитьПодписьФайлаДокумента(ИмяФайлаДляТеста, Отпечаток, ПарольКонтейнера);
	УдалитьФайлы(ИмяФайлаДляТеста);
	
	Результат.ОписаниеОшибки = РезультатПодписания.ОписаниеОшибки;
	Результат.Успешно = РезультатПодписания.Успешно;
		
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПроверитьЛогинПарольДД(ДанныеАвторизации)
	
	// Проверим, что можем авторизоваться с указанными данными
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	Если Не ЗначениеЗаполнено(ДанныеАвторизации.ЛогинДД) 
		ИЛИ Не ЗначениеЗаполнено(ДанныеАвторизации.ПарольДД) Тогда
		Результат.ОписаниеОшибки = "Не указаны логин или пароль для доступа в Диадок.";
		ОбновитьДанныеАвторизации("ЛогинПарольДДПроверен", Истина);
		Возврат Результат;
	КонецЕсли;
	
	HttpЗаголовки = Новый Соответствие;
	HttpЗаголовки.Вставить("Authorization","DiadocAuth ddauth_api_client_id="+КлючАвторизацииAPI());// konturediauth_login="""+УчетнаяЗапись.Логин+""" , konturediauth_password="""+УчетнаяЗапись.Пароль+"""";
	ИмяРесурса = "/Authenticate";
	ПараметрыСтрокиЗапроса = "login=" + ДанныеАвторизации.ЛогинДД + "&password=" + ДанныеАвторизации.ПарольДД;
	ТипыДанных 	= Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "Строка");
	ТелоЗапроса = "";
	
	Попытка
		РезультатВыполнения = ВыполнитьЗапросAPI(СоединениеДД(), ИмяРесурса, ПараметрыСтрокиЗапроса, HttpЗаголовки, "POST", ТелоЗапроса, ТипыДанных);
	Исключение
		_ИнформацияОбОшибке = ИнформацияОбОшибке();
		Результат.ОписаниеОшибки = "Не удалось выполнить запрос " + ИмяРесурса + " на клиенте: " + _ИнформацияОбОшибке.Причина.Описание;
	КонецПопытки;
	
	Если Не РезультатВыполнения.Успешно Тогда
		Результат.ОписаниеОшибки = "Запрос " + ИмяРесурса + " выполнен на клиенте с ошибкой: " + РезультатВыполнения.ОписаниеОшибки;
	КонецЕсли;
	
	ОбновитьДанныеАвторизации("ЛогинПарольДДПроверен", Истина);
	ОбновитьДанныеАвторизации("ВалидацияЛогинаПароляДДПройдена", РезультатВыполнения.Успешно);
	Результат.Успешно = РезультатВыполнения.Успешно;
	
  	Возврат Результат;

КонецФункции

&НаКлиенте
Функция УзнатьСостояниепоСФ(ЗНАЧ Организация,ЗНАЧ BoxId,ЗНАЧ MessageId) Экспорт
	
	СтруктураРезультата = ИнициализироватьСтруктуруРезультатаФункции();
	ИнициализироватьДанныеАвторизации(Организация);
	
	Если ДанныеАвторизации = Неопределено Тогда
		// не удалось получить данные авторизации
		Возврат СтруктураРезультата;
	КонецЕсли;
	
	Если (ПропускЛогинаПароляДДПоОрганизации(Организация)
		И Не СертификатПоОрганизацииНазначен(Организация))
		ИЛИ (ПропускЛогинаПароляДДПоОрганизации(Организация)
		И ПропускСертификатаПоОрганизации(Организация)) Тогда
		// не удалось авторизоваться с указанными данными
		Возврат СтруктураРезультата;
	КонецЕсли;

	Если Не ДанныеАвторизации.ЛогинПарольДДПроверен = Истина Тогда
		
		// сначала авторизуемся по логину и паролю
		ОбновитьДанныеАвторизации("ТипАвторизации", "ЛогинПароль");
		РезультатПроверкиЛогинаПароляДД = ПроверитьЛогинПарольДД(ДанныеАвторизации);
		
	КонецЕсли;
		
	Если ПропускЛогинаПароляДДПоОрганизации(Организация)
		И СертификатПоОрганизацииНазначен(Организация)
		И Не ДанныеАвторизации.СертификатПроверен Тогда
		
		// если авторизоваться по логину и паролю не удалось, будем пробовать по сертификату
		ОбновитьДанныеАвторизации("ТипАвторизации", "Сертификат");
		РезультатПроверкиСертификата = Новый Структура("Успешно, ОписаниеОшибки");
		
		ПарольКонтейнера = "";
		РезультатПроверки = ПроверитьВыбранныйСертификат(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток, ПарольКонтейнера);
		
		Если Не ИспользоватьCapicom
			И РезультатПроверки.Успешно = Ложь
			И ОшибкаНеправильныйПарольКонтейнера(РезультатПроверки.ОписаниеОшибки) Тогда
			
			ПарольКонтейнера = ПолучитьПарольКонтейнераСертификатаСервер(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток);
			РезультатПроверки = ПроверитьВыбранныйСертификат(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток, ПарольКонтейнера);
			
		КонецЕсли;

		ОбновитьДанныеАвторизации("СертификатПроверен", Истина);
		
		Если РезультатПроверки.Успешно = Истина Тогда
			ОбновитьДанныеАвторизации("ПарольКонтейнера", ПарольКонтейнера);
			ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Истина);
		Иначе
			ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Ложь);
		КонецЕсли;
		
		РезультатПроверкиСертификата.Успешно = РезультатПроверки.Успешно;
		РезультатПроверкиСертификата.ОписаниеОшибки = РезультатПроверки.ОписаниеОшибки;
			
	КонецЕсли;
	
	Если ПропускЛогинаПароляДДПоОрганизации(Организация) Тогда 
		
		Если СертификатПоОрганизацииНазначен(Организация)
			И ПропускСертификатаПоОрганизации(Организация) Тогда
			
			СтруктураРезультата.ОписаниеОшибки = РезультатПроверкиСертификата.ОписаниеОшибки;
			
			Если ЗначениеЗаполнено(ДанныеАвторизации.СертификатДействуетПо)
				И КонецДня(ДанныеАвторизации.СертификатДействуетПо) < ТекущаяДата() Тогда
			    СтруктураРезультата.ОписаниеОшибки = "Истек срок действия сертификата." + Символы.ПС + СтруктураРезультата.ОписаниеОшибки;
			КонецЕсли; 
				
			Возврат СтруктураРезультата;
			
		ИначеЕсли Не СертификатПоОрганизацииНазначен(Организация) Тогда
			
			СтруктураРезультата.ОписаниеОшибки = РезультатПроверкиЛогинаПароляДД.ОписаниеОшибки;
			Возврат СтруктураРезультата;

		КонецЕсли; 
		
	КонецЕсли; 
	
	СтруктураРезультата.Вставить("СтатусСФ","");    			//статусы подписей
	СтруктураРезультата.Вставить("СтатусТорг12","");
	СтруктураРезультата.Вставить("СтатусУПД","");
	
	СтруктураРезультата.Вставить("ФлагЗапросаУточненияСФ","");  //уточнений
	СтруктураРезультата.Вставить("ФлагЗапросаУточненияУПД","");
	
	СтруктураРезультата.Вставить("СтатусАннулированияСФ","");   //аннулирований
	СтруктураРезультата.Вставить("СтатусАннулированияТорг12","");
	СтруктураРезультата.Вставить("СтатусАннулированияУПД","");
	
	СтруктураРезультата.Вставить("КомментарийКЗапросуУточнения","");  //комментариев
	СтруктураРезультата.Вставить("КомментарийКОтказуВПодписи","");
	СтруктураРезультата.Вставить("КомментарийКЗапросуАннулированияСФ","");
	СтруктураРезультата.Вставить("КомментарийКЗапросуАннулированияТорг12","");
	СтруктураРезультата.Вставить("КомментарийКЗапросуАннулированияУПД","");
	
	Message = ПолучитьMessage(BoxId, MessageId, ДанныеАвторизации);
	СтруктураРезультата.Успешно = Message.Успешно;
	
	Если  Message.Успешно Тогда
		//мы будем искать среди entities:
		//Invoice
		//XmlTorg12
		//UniversalTransferDocument
		
		Для каждого Entity из Message.Значение.Entities Цикл
			Если Entity.AttachmentType = "Invoice" Тогда
				СтруктураРезультата.СтатусСФ = Entity.DocumentInfo.InvoiceMetadata.InvoiceStatus;
				СтруктураРезультата.ФлагЗапросаУточненияСФ = Entity.DocumentInfo.InvoiceMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияСФ = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияСФ = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияСФ=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "InvoiceCorrection" Тогда
				СтруктураРезультата.СтатусСФ = Entity.DocumentInfo.InvoiceCorrectionMetadata.InvoiceCorrectionStatus;
				СтруктураРезультата.ФлагЗапросаУточненияСФ = Entity.DocumentInfo.InvoiceCorrectionMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияСФ = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияСФ = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияСФ=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "InvoiceRevision" Тогда
				СтруктураРезультата.СтатусСФ = Entity.DocumentInfo.InvoiceRevisionMetadata.InvoiceRevisionStatus;
				СтруктураРезультата.ФлагЗапросаУточненияСФ = Entity.DocumentInfo.InvoiceRevisionMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияСФ = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияСФ = "RevocationStatusNone" Тогда 
					СтруктураРезультата.СтатусАннулированияСФ=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "XmlTorg12" Тогда
				СтруктураРезультата.СтатусТорг12 = Entity.DocumentInfo.XmlTorg12Metadata.DocumentStatus;
				СтруктураРезультата.СтатусАннулированияТорг12 = Entity.DocumentInfo.RevocationStatus;           
				Если СтруктураРезультата.СтатусАннулированияТорг12 = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияТорг12=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "UniversalTransferDocument" Тогда
				СтруктураРезультата.СтатусУПД = Entity.DocumentInfo.UniversalTransferDocumentMetadata.DocumentStatus;
				СтруктураРезультата.ФлагЗапросаУточненияУПД = Entity.DocumentInfo.UniversalTransferDocumentMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияУПД = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияУПД = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияУПД=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "UniversalTransferDocumentRevision" Тогда
				СтруктураРезультата.СтатусУПД = Entity.DocumentInfo.UniversalTransferDocumentRevisionMetadata.DocumentStatus;
				СтруктураРезультата.ФлагЗапросаУточненияУПД = Entity.DocumentInfo.UniversalTransferDocumentRevisionMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияУПД = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияУПД = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияУПД=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "UniversalCorrectionDocument" Тогда
				СтруктураРезультата.СтатусУПД = Entity.DocumentInfo.UniversalCorrectionDocumentMetadata.DocumentStatus;
				СтруктураРезультата.ФлагЗапросаУточненияУПД = Entity.DocumentInfo.UniversalCorrectionDocumentMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияУПД = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияУПД = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияУПД=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			Если Entity.AttachmentType = "UniversalCorrectionDocumentRevision" Тогда
				СтруктураРезультата.СтатусУПД = Entity.DocumentInfo.UniversalCorrectionDocumentRevisionMetadata.DocumentStatus;
				СтруктураРезультата.ФлагЗапросаУточненияУПД = Entity.DocumentInfo.UniversalCorrectionDocumentRevisionMetadata.InvoiceAmendmentFlags;
				СтруктураРезультата.СтатусАннулированияУПД = Entity.DocumentInfo.RevocationStatus;
				Если СтруктураРезультата.СтатусАннулированияУПД = "RevocationStatusNone" Тогда 
					 СтруктураРезультата.СтатусАннулированияУПД=""; //не будем никого путать этот статус проще вообще не показывать 
				КонецЕсли;
			КонецЕсли;
			//здесь ищем сами сущности корректировок чтобы прочитать из них комментарий
			Если Entity.AttachmentType = "InvoiceCorrectionRequest" Тогда
				СтруктураРезультата.КомментарийКЗапросуУточнения = ПрочитатьКомментарийУточненияИлиОтказа(BoxId,MessageId,Entity.EntityId,ДанныеАвторизации);
			КонецЕсли;                                             
			Если Entity.AttachmentType = "XmlSignatureRejection" Тогда
				СтруктураРезультата.КомментарийКОтказуВПодписи = ПрочитатьКомментарийУточненияИлиОтказа(BoxId,MessageId,Entity.EntityId,ДанныеАвторизации);
			КонецЕсли;                                             
			Если Entity.AttachmentType = "RevocationRequest" Тогда
				РодительЗапросаАннулирования = ОпределитьРодителяEntity(Message.Значение.Entities,Entity);
				КомментарийКЗапросуАннулирования = ПрочитатьКомментарийЗапросаАннулирования(BoxId,MessageId,Entity.EntityId,ДанныеАвторизации);
				Если РодительЗапросаАннулирования.AttachmentType = "Invoice" Тогда
					СтруктураРезультата.КомментарийКЗапросуАннулированияСФ = КомментарийКЗапросуАннулирования;
				ИначеЕсли РодительЗапросаАннулирования.AttachmentType = "XmlTorg12" Тогда
					СтруктураРезультата.КомментарийКЗапросуАннулированияТОРГ12 = КомментарийКЗапросуАннулирования;
				ИначеЕсли РодительЗапросаАннулирования.AttachmentType = "UniversalTransferDocument" Тогда
					СтруктураРезультата.КомментарийКЗапросуАннулированияУПД = КомментарийКЗапросуАннулирования;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		СтруктураРезультата.ОписаниеОшибки = Message.ОписаниеОшибки;
	КонецЕсли;
	
	Возврат  СтруктураРезультата
	
КонецФункции

&НаКлиенте
Функция ОпределитьРодителяEntity(МассивEntities,ТекEntityИзМассива)
	
	Для каждого Entity из МассивEntities Цикл
		Если ТекEntityИзМассива.ParentEntityId = Entity.EntityId Тогда 
			Возврат Entity;
		КонецЕсли;
	КонецЦикла;
		
	Возврат Неопределено;

КонецФункции // ОпределитьРодителяEntity()

&НаКлиенте
Функция СохранитьКонтентВФайл(BoxId,MessageId,EntityId,ДанныеАвторизации)
	
	мРабочийКаталог=КаталогВременныхФайлов();
	ПутьКФайлу=мРабочийКаталог+EntityId;
	ВременныйФайл = Новый Файл(ПутьКФайлу);
	Если ВременныйФайл.Существует() Тогда
		УдалитьФайлы(ВременныйФайл.ПолноеИмя);//Если такой файл уже есть в temp, значит, он остался от предыдущей сессии, когда чо-то пошло не так. Удалим его.
	КонецЕсли;
	
 	Результат=СохранитьКонтентВложения(BoxId, MessageId, EntityId, ДанныеАвторизации, ПутьКФайлу);
	Результат.Вставить("ПутьКФайлу",ПутьКФайлу);
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПолучитьТекстФайлаКонтента(BoxId,MessageId,EntityId,ДанныеАвторизации)
	
	РезультатСохраненияКонтента=СохранитьКонтентВФайл(BoxId,MessageId,EntityId,ДанныеАвторизации);
	
	Если РезультатСохраненияКонтента.Успешно = Истина Тогда 
		//из файлика нам нужен тег <ТекстУведУточ>
		
	ТекстXML=Новый ТекстовыйДокумент;
	ТекстXML.Прочитать(РезультатСохраненияКонтента.ПутьКФайлу);
	ТекстXML = ТекстXML.ПолучитьТекст();
	
		Возврат ТекстXML;
	Иначе
		СП = Новый СообщениеПользователю;
		СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
		СП.Текст = РезультатСохраненияКонтента.ОписаниеОшибки;
		СП.Сообщить();
		Возврат "Не удалось прочитать комментарий";
	КонецЕсли;

КонецФункции

&НаКлиенте
Функция ПрочитатьКомментарийУточненияИлиОтказа(BoxId,MessageId,EntityId,ДанныеАвторизации)
	
	ТекстXML=ПолучитьТекстФайлаКонтента(BoxId,MessageId,EntityId,ДанныеАвторизации);
	
	//не будим загонять в XDTO
	ПозСутиКомментария=Найти(ТекстXML,"<ТекстУведУточ>");
	Если ПозСутиКомментария<>0 Тогда
		ПозОкончанияКомментария=Найти(ТекстXML,"</ТекстУведУточ>");
		ТекстКомментария=Сред(ТекстXML,ПозСутиКомментария+15,ПозОкончанияКомментария-ПозСутиКомментария-15);
		Возврат СокрЛП(ТекстКомментария);
	Иначе
		Возврат ?(ЗначениеЗаполнено(ТекстXML),ТекстXML,"");
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ПрочитатьКомментарийЗапросаАннулирования(BoxId,MessageId,EntityId,ДанныеАвторизации)
	
	ТекстXML=ПолучитьТекстФайлаКонтента(BoxId,MessageId,EntityId,ДанныеАвторизации);
	//даже не будим загонять в XDTO
	ПозСутиКомментария=Найти(ТекстXML,"<ТекстПредАн>");
	Если ПозСутиКомментария<>0 Тогда
		ПозОкончанияКомментария=Найти(ТекстXML,"</ТекстПредАн>");
		ТекстКомментария=Сред(ТекстXML,ПозСутиКомментария+13,ПозОкончанияКомментария-ПозСутиКомментария-13);
		Возврат СокрЛП(ТекстКомментария);
	Иначе
		Возврат ?(ЗначениеЗаполнено(ТекстXML),ТекстXML,"");
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ПолучитьСостояниеСообщенияINVOICПоСостояниюЮЗДО(СтруктураСостояния) Экспорт
	
	Возврат ПолучитьСостояниеСообщенияINVOICПоСостояниюЮЗДОСервер(СтруктураСостояния);
	
КонецФункции

&НаСервере
Функция ПолучитьСостояниеСообщенияINVOICПоСостояниюЮЗДОСервер(СтруктураСостояния)

	Возврат МодульОбъекта().ПолучитьСостояниеСообщенияINVOICПоСостояниюЮЗДО(СтруктураСостояния)	
	
КонецФункции 

&НаКлиенте
Процедура СброситьПроверкиДанныхАвторизации() Экспорт

	Для каждого Строка Из ТаблицаАвторизации Цикл
		
		Строка.ЛогинПарольДДПроверен 			= Ложь;
		Строка.СертификатПроверен 				= Ложь;
		Строка.ВалидацияЛогинаПароляДДПройдена 	= Ложь;
		Строка.ВалидацияСертификатаПройдена 	= Ложь;
	
	КонецЦикла;

КонецПроцедуры

&НаКлиенте
Процедура СброситьПарольКонтейнераДанныхАвторизации() Экспорт
	
	ОбновитьДанныеАвторизации("ПарольКонтейнера", "");

	Для каждого Строка Из ТаблицаАвторизации Цикл
		Строка.ПарольКонтейнера	= "";
	КонецЦикла;

КонецПроцедуры

&НаКлиенте
Процедура ПодписатьСчетаФактуры()
	
	мРабочийКаталог = КаталогВременныхФайлов();
	Прогресс = 0;
	Всего = СчетаФактурыНаПодписание.Количество();
	
	Для Каждого СчетФактураКПодписи Из СчетаФактурыНаПодписание Цикл
		
		Прогресс = Прогресс + 1;
		ТекПроцент = Цел((Прогресс * 100 / Всего)); 
		Состояние("Подписание: " + Прогресс + " из " + Всего, ТекПроцент);
		
		Если ПропускСертификатаПоОрганизации(СчетФактураКПодписи.Организация) Тогда
			// по какой-то причине не удалось выбрать сертификат или не прошли проверку с сертификатом
			Продолжить; 
		КонецЕсли;
		
		MessageЧерновик = ПолучитьMessage(СчетФактураКПодписи.BoxId,СчетФактураКПодписи.MessageId,ДанныеАвторизации);
		
		Если MessageЧерновик.Успешно = Ложь Тогда
			СП = Новый СообщениеПользователю;
			СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
			СП.Текст = MessageЧерновик.ОписаниеОшибки;
			СП.Сообщить();
			Возврат;
		КонецЕсли;
		
		MessagePatchToPost = Новый Структура;  //это итоговая структура, которую будем отправлять
		MessagePatchToPost.Вставить("BoxId", 		СчетФактураКПодписи.BoxId);
		MessagePatchToPost.Вставить("DraftId", 	СчетФактураКПодписи.MessageId);
		
		// Временный массив, куда сложим все  Entities, которые нужно подписать
		EntitiesДляПодписания = ПолучитьEntitiesДляПодписания(MessageЧерновик);
		
		// Массив, перед подписанием проставим подписантов во всех Entites документов Message.
		PatchedEntities = ПолучитьPatchedEntities(EntitiesДляПодписания, СчетФактураКПодписи, ДанныеАвторизации);
		Если Не ЗначениеЗаполнено(PatchedEntities) Тогда
			Возврат;
		КонецЕсли;
		
		// это нужно будет добавить в MessagePatchToPost как DocumentSignatures (ниже)
		// в ней будут все подписанные attachement от этого сообщения
		МассивСтруктур = Новый Массив;   

		Для Каждого PatchedEntity Из PatchedEntities Цикл
			РезультатПодписания = ПодписатьPatchedEntity(PatchedEntity, МассивСтруктур, ДанныеАвторизации);
			Если РезультатПодписания.Успешно = Ложь Тогда
				СП = Новый СообщениеПользователю;
				СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
				СП.Текст = РезультатПодписания.ОписаниеОшибки;
				СП.Сообщить();
	            Возврат;
			КонецЕсли;
		КонецЦикла;
		
		MessagePatchToPost.Вставить("DocumentSignatures", 	МассивСтруктур);
		
		//Отправка
		Если МассивСтруктур.Количество()>0 Тогда 
			Результат=ОтправитьSendDraft(MessagePatchToPost,ДанныеАвторизации);  //sendDraft - очень похож на патч.
			
			//Отражение результатов - укажем в нашей табличке новые идентификаторы
			Если Результат<>Неопределено Тогда 
				Если ТипЗнч(Результат)=Тип("Структура") Тогда 
					СчетФактураКПодписи.MessageId_new=Результат.MessageId;
					//теперь найти invoiceID, torg12Id, updID
					Если ТипЗнч(Результат.Entities)=Тип("Массив")
						И Результат.Entities.Количество()>0 Тогда 
						Для Каждого Entity из Результат.Entities Цикл
							Если Entity.AttachmentType="Invoice" или Entity.AttachmentType="InvoiceCorrection" Тогда 
								СчетФактураКПодписи.InvoiceId_new = Entity.EntityId;
							ИначеЕсли Entity.AttachmentType="XmlTorg12" Тогда 
								СчетФактураКПодписи.torg12Id_new = Entity.EntityId;
							ИначеЕсли Entity.AttachmentType = "UniversalTransferDocument" или Entity.AttachmentType = "UniversalTransferDocumentRevision" Тогда 
								СчетФактураКПодписи.UniversalTransferDocumentId_new = Entity.EntityId;     //УПД
							ИначеЕсли Entity.AttachmentType = "UniversalCorrectionDocument" или Entity.AttachmentType = "UniversalCorrectionDocumentRevision" Тогда 
								СчетФактураКПодписи.UniversalTransferDocumentId_new = Entity.EntityId;     //УКД пишем тоже в  UniversalTransferDocumentId
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	
	КонецЦикла;
	
	Состояние("Подписание завершено.");
	
КонецПроцедуры

&НаКлиенте
Функция ОтправитьSendDraft(MessagePatchToPost,ДанныеАвторизации)
	
	Результат = SendDraft(ЗаписатьJSONВызовСервера(MessagePatchToPost),"",ДанныеАвторизации);
	
	Если Не Результат.Успешно Тогда
		СП = Новый СообщениеПользователю;
		СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
		СП.Текст = Результат.ОписаниеОшибки;
		СП.Сообщить();
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат.Значение;		
	
КонецФункции

&НаСервере
Функция ЗаписатьJSONВызовСервера(СтруктураВjson)
	
	Возврат МодульОбъекта().ЗаписатьJSON_(СтруктураВjson);	

КонецФункции

&НаКлиенте
Функция ПолучитьMessage(BoxId,MessageId,ДанныеАвторизации)
	
	Возврат GetMessage(BoxId, MessageId, , , ДанныеАвторизации);								
	
КонецФункции

&НаКлиенте
Функция GetMessage(BoxId, messageId, entityId = Неопределено, originalSignature = Неопределено, ДанныеАвторизации)
	
	ПараметрыСтрокиЗапроса = "BoxId="+BoxId+"&messageId="+messageId;
	Если Не entityId = Неопределено Тогда
		ПараметрыСтрокиЗапроса = ПараметрыСтрокиЗапроса + "&entityId="+entityId;	
	КонецЕсли;
	Если Не originalSignature = Неопределено Тогда
		ПараметрыСтрокиЗапроса = ПараметрыСтрокиЗапроса + "&originalSignature="+originalSignature;	
	КонецЕсли;
	ТипыДанных = Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "Строка");
	
	Результат = ВызватьМетодAPI("/V3/GetMessage",ПараметрыСтрокиЗапроса,"GET","","",ДанныеАвторизации,ТипыДанных);
	Если Не Результат.Успешно Тогда
		Возврат Результат;
	КонецЕсли;
	
	Результат.Значение = DoParseВызовСервера(Результат.Значение);
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция GetInvoiceCorrectionRequestInfo(BoxId, messageId, entityId, ДанныеАвторизации)
	
	ПараметрыСтрокиЗапроса = "BoxId="+BoxId+"&messageId="+messageId;
	Если Не entityId = Неопределено Тогда
		ПараметрыСтрокиЗапроса = ПараметрыСтрокиЗапроса + "&entityId="+entityId;	
	КонецЕсли;
	ТипыДанных = Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "Строка");
	
	Результат = ВызватьМетодAPI("/GetInvoiceCorrectionRequestInfo",ПараметрыСтрокиЗапроса,"GET","","",ДанныеАвторизации,ТипыДанных);
	Если Не Результат.Успешно Тогда
		Возврат Результат;
	КонецЕсли;
	
	Результат.Значение = DoParseВызовСервера(Результат.Значение);
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция SendDraft(RequestBody, operationId="", ДанныеАвторизации)     //аналог PostMessagePatch для черновиков
	
	ПараметрыСтрокиЗапроса = "";
	Если Не ПустаяСтрока(operationId) Тогда
		ПараметрыСтрокиЗапроса = ПараметрыСтрокиЗапроса + "operationId="+operationId;
	КонецЕсли;
	ТипыДанных = Новый Структура("ТипТелаЗапроса,ТипТелаОтвета","Строка","Строка");
	
	Результат = ВызватьМетодAPI("/SendDraft",ПараметрыСтрокиЗапроса,"POST","",RequestBody, ДанныеАвторизации, ТипыДанных);
	
	Результат.Значение = DoParseВызовСервера(Результат.Значение);
	Возврат Результат;	
	
КонецФункции

&НаСервере
Функция DoParseВызовСервера(Строка)
	Возврат МодульОбъекта().DoParse(Строка);
КонецФункции

&НаКлиенте
Функция ПолучитьПодписьФайлаДокумента(ПутьКФайлу, Отпечаток, ПарольКонтейнера = "") Экспорт
	
	//серверный аналог функции расположен в модуле объекта
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	Попытка

		Если ИспользоватьCapicom Тогда
			
			Скрипт = Новый COMОбъект("MSScriptControl.ScriptControl");
			Скрипт.language = "vbscript";
			
			Сертификат = ПолучитьСертификатCapicom(Отпечаток,3);
			
			ТекстСкрипта = "
			|Const FileTypeBinary = 1
			|
			|Function SignFile(SourceFile)
			|
			|	Set objStream = CreateObject(""ADODB.Stream"")
			|	With objStream
			|		.Type = FileTypeBinary
			|		.Open
			|		.LoadFromFile SourceFile
			|	End With
			|	dataToSign = objStream.Read
			|	Set oSigner = CreateObject(""CAPICOM.Signer"")
			|	oSigner.Certificate = certificate
			|	oSigner.Options = 2
			|	Set oSignedData = CreateObject(""CAPICOM.SignedData"")
			|	oSignedData.Content = dataToSign
			|	sSignedMessage = oSignedData.Sign(oSigner, true)
			|
			|	SignFile = sSignedMessage
			|End Function
			|";
			
			Скрипт.AddObject("certificate", Сертификат);
			Скрипт.AddCode(ТекстСкрипта);
			
			ШифрованнаяПодпись = Скрипт.CodeObject.SignFile(ПутьКФайлу);
			ШифрованнаяПодпись = Лев(ШифрованнаяПодпись,СтрДлина(ШифрованнаяПодпись)-2);
			
		Иначе
			
			Сертификат = ПолучитьСертификат1СПоОтпечатку(Отпечаток);
			Подпись = МенеджерКриптографии1С(ПарольКонтейнера).Подписать(ПутьКФайлу, Сертификат);
			ШифрованнаяПодпись = Base64Строка(Подпись);
			
		КонецЕсли;
		
		Результат.Успешно = Истина;
		Результат.Вставить("ШифрованнаяПодпись", ШифрованнаяПодпись);
		
	Исключение
		
		_ИнформацияОбОшибке = ИнформацияОбОшибке();
		Результат.ОписаниеОшибки = _ИнформацияОбОшибке.Причина.Описание;
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция СохранитьКонтентВложения(BoxId, MessageId, EntityId, ДанныеАвторизации, ПутьКФайлу)
	
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	РезультатGetEntityContent = GetEntityContent(BoxId, MessageId, EntityId, ДанныеАвторизации);
	Если Не РезультатGetEntityContent.Успешно Тогда
		Результат.ОписаниеОшибки = РезультатGetEntityContent.ОписаниеОшибки;
		Возврат Результат;
 	КонецЕсли;
	EntityContent = РезультатGetEntityContent.Значение;
	
	COMSafeArrayToFile(EntityContent,ПутьКФайлу);
	
	ФайлКонтентаВложения = Новый Файл(ПутьКФайлу);
	Если Не ФайлКонтентаВложения.Существует() Тогда
		Результат.ОписаниеОшибки = "не удалось сохранить файл на диск";
		Возврат Результат;			
	КонецЕсли;
		
	Результат.Успешно = Истина;
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция GetEntityContent(BoxId, MessageId, EntityId, ДанныеАвторизации)
			
	ПараметрыСтрокиЗапроса = "boxId="+BoxId + "&messageId="+MessageId + "&entityId="+EntityId;
	ТипыДанных 	= Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "ДвоичныеДанные");
	
	Возврат ВызватьМетодAPI("/V4/GetEntityContent",ПараметрыСтрокиЗапроса,"GET","","", ДанныеАвторизации, ТипыДанных);
			
КонецФункции

&НаКлиенте
Функция COMSafeArrayToFile(ComSafeArray,ПутьКФайлу)
	
	Попытка	
	    StreamOut = Новый COMОбъект("ADODB.Stream");
		StreamOut.Type = 1; //двоичные данные (2-текстовые данные)
		StreamOut.Mode = 3; //чтение/запись
		StreamOut.Open();
		StreamOut.Write(ComSafeArray); 
		StreamOut.SaveToFile(ПутьКФайлу, 2);
		StreamOut.Close();
	Исключение
	КонецПопытки;
	
КонецФункции

&НаКлиенте
Функция COMSafeArrayToBinary(МассивДанных)
	
	МассивШестнадцатеричныхЧисел = МассивШестнадцатеричныхЧисел();
	
	// Обрабатываем данные
	
	СтрокаДанных = "";
	Для Каждого Значение Из МассивДанных Цикл
		СтрокаДанных = СтрокаДанных + МассивШестнадцатеричныхЧисел[Значение];
	КонецЦикла;
	
	ДвоичныеДанные = ПреобразоватьСтрокуДанныхВДвоичныеДанные(СтрокаДанных);
	
	Возврат ДвоичныеДанные;

КонецФункции

&НаКлиенте
Функция МассивШестнадцатеричныхЧисел()

	МассивШестнадцатеричныхЧисел = Новый Массив(256);
	
	Словарь = "0123456789ABCDEF";
	Для Счт1 = 0 По 15 Цикл
		Для Счт2 = 0 По 15 Цикл
			МассивШестнадцатеричныхЧисел[Счт1 * 16 + Счт2] = Сред(Словарь, Счт1 + 1, 1) + Сред(Словарь, Счт2 + 1, 1);
		КонецЦикла;
	КонецЦикла;
	
	Возврат МассивШестнадцатеричныхЧисел;
	
КонецФункции // МассивШестнадцатеричныхЧисел()

&НаКлиенте
Функция ИнициализироватьСтруктуруРезультатаФункции()
	
	СтруктураРезультата = Новый Структура();
	
	СтруктураРезультата.Вставить("Успешно",			Ложь);
	СтруктураРезультата.Вставить("ОписаниеОшибки",	"");
	
	Возврат СтруктураРезультата;
	
КонецФункции

&НаКлиенте
Функция ВызватьМетодAPI(ИмяРесурса, ПараметрыСтрокиЗапроса="", Метод, УчетнаяЗапись, ТелоЗапроса="", ДанныеАвторизации, ТипыДанных)
		
	Результат = Новый Структура("Успешно,Значение,ОписаниеОшибки",Ложь,Неопределено,"");
	
	//работаем через COM-объект Mictosoft.XMLHTTP, а значит через IE, который кэширует запросы по АдресуЗапроса
	//для исключения кэширования к АдресуЗапроса добавляем параметр ParamPresentTime, содержащим текущее время с точностью до секунд
	ПараметрыСтрокиЗапроса = ПараметрыСтрокиЗапроса + ?(ПараметрыСтрокиЗапроса="","","&")+"presentTime="+Формат(ТекущаяДата(),"ДФ=yyyyMMddHHmmss");
	
	ИмяФайлаОтвета = ПолучитьИмяВременногоФайла();			
	
	Для НомерПопытки = 1 По 2 Цикл //после первой попытки можем переподключиться
		
		Токен = Токен(ДанныеАвторизации);
		Если Токен = Неопределено И ДанныеАвторизации.ТипАвторизации = "Сертификат" Тогда
			Результат.ОписаниеОшибки = "Отсутствует авторизация по клиентскому сертификату";
			Возврат Результат;					
		КонецЕсли;
		
		HttpЗаголовки = Новый Соответствие;
		HttpЗаголовки.Вставить("Authorization","DiadocAuth ddauth_api_client_id="+КлючАвторизацииAPI()+",ddauth_token="+Токен);
		HttpЗаголовки.Вставить("Accept","application/json");//без этого вернется протобуфер
		HttpЗаголовки.Вставить("Content-Type","application/json; charset=utf-8");//для отправки в JSON вместо protobuf
		
		Попытка
			РезультатВыполнения = ВыполнитьЗапросAPI(СоединениеДД(),ИмяРесурса,ПараметрыСтрокиЗапроса,HttpЗаголовки,Метод,ТелоЗапроса,ТипыДанных);
 		Исключение
			_ОписаниеОшибки = ОписаниеОшибки();
		КонецПопытки;
		
		Если РезультатВыполнения = Неопределено Тогда
			Продолжить;
		ИначеЕсли РезультатВыполнения.Успешно Тогда
			ЗаполнитьЗначенияСвойств(Результат,РезультатВыполнения);
			Прервать;
		ИначеЕсли Не РезультатВыполнения.Успешно Тогда
			ЗаполнитьЗначенияСвойств(Результат,РезультатВыполнения);
			Если НомерПопытки = 1 Тогда
				ОшибкаАвторизации = ОшибкаАвторизацииПоHttpКодуВозврата(ИмяРесурса,РезультатВыполнения.HttpКодВозврата);
				Если ОшибкаАвторизации Тогда
				    Токен(ДанныеАвторизации, Ложь);
				КонецЕсли;
			Иначе
				ЗарегистрироватьОшибкуАвторизации(ДанныеАвторизации.Организация,РезультатВыполнения.ОписаниеОшибки);
			КонецЕсли;
		КонецЕсли;		
		
	КонецЦикла;
		
	Возврат Результат;	
	
КонецФункции

//заполнение

//-------------------------------------------------------------------------------------------------
// Отправка извещений о получении
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Процедура ОтправитьИзвещенияОПолучении() Экспорт
	
	СброситьПроверкиДанныхАвторизации();	
	СформироватьСчетаФактурыДляОтправкиИзвещений();
 
	мРабочийКаталог = КаталогВременныхФайлов();
	Прогресс = 0;
	Всего = СчетаФактурыНаПодписание.Количество();
	ТекОрганизация = Неопределено;
	
	Для каждого СтрокаСЧФ Из СчетаФактурыНаПодписание Цикл
		
		Прогресс = Прогресс + 1;
		ТекПроцент = Цел((Прогресс * 100 / Всего)); 
		Состояние("Отправка извещений: " + Прогресс + " из " + Всего, ТекПроцент);
		
		Если ТекОрганизация <> СтрокаСЧФ.Организация Тогда
			
			ТекОрганизация = СтрокаСЧФ.Организация;
			ИнициализироватьДанныеАвторизации(ТекОрганизация);
			ОбновитьДанныеАвторизации("ТипАвторизации", "Сертификат"); 
			
			Если Не СертификатПоОрганизацииНазначен(ТекОрганизация) Тогда
				Продолжить;
			КонецЕсли;
			
			Если Не ДанныеАвторизации.СертификатПроверен Тогда
				
				ПарольКонтейнера = "";
				РезультатПроверки = ПроверитьВыбранныйСертификат(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток, ПарольКонтейнера);
				
				Если Не ИспользоватьCapicom
					И РезультатПроверки.Успешно = Ложь
					И ОшибкаНеправильныйПарольКонтейнера(РезультатПроверки.ОписаниеОшибки) Тогда
					
					ПарольКонтейнера = ПолучитьПарольКонтейнераСертификатаСервер(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток);
					РезультатПроверки = ПроверитьВыбранныйСертификат(ДанныеАвторизации.Организация, ДанныеАвторизации.Отпечаток, ПарольКонтейнера);
					
				КонецЕсли;
				
				ОбновитьДанныеАвторизации("СертификатПроверен", Истина);
				
				Если РезультатПроверки.Успешно = Истина Тогда
					ОбновитьДанныеАвторизации("ПарольКонтейнера", ПарольКонтейнера);
					ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Истина);
				Иначе
					ОбновитьДанныеАвторизации("ВалидацияСертификатаПройдена", Ложь);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПропускСертификатаПоОрганизации(ТекОрганизация) Тогда
			Продолжить; 
		КонецЕсли;
		
		СформироватьИОтправитьИзвещенияОПолучении(СтрокаСЧФ.boxId, СтрокаСЧФ.messageId, СтрокаСЧФ.Ссылка, ДанныеАвторизации);
	
	КонецЦикла;
	
	СброситьПарольКонтейнераДанныхАвторизации();
	
КонецПроцедуры

&НаСервере
Процедура СформироватьСчетаФактурыДляОтправкиИзвещений()
	
	СчетаФактурыНаПодписание.Загрузить(МодульОбъекта().ИзвлечьИзВХ("ТабСФДляОтправкиИзвещений"));
	
КонецПроцедуры

&НаКлиенте
Процедура СформироватьИОтправитьИзвещенияОПолучении(boxId, messageId, СообщениеСсылка, ДанныеАвторизации)
	
	РезультатПолученияMessage = ПолучитьMessage(boxId, messageId, ДанныеАвторизации);

	Если РезультатПолученияMessage.Успешно = Ложь Тогда
		СП = Новый СообщениеПользователю;
		СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
		СП.Текст = "Не удалось получить документы для формирования извещения по причине: " + РезультатПолученияMessage.ОписаниеОшибки;
		СП.Сообщить();
		Возврат;
	КонецЕсли;
	
	СписокParentEntityIdИзвещенийДляОтправки = ПолучитьСписокParentEntityIdИзвещенийДляОтправки(РезультатПолученияMessage.Значение);
	
	Если СписокParentEntityIdИзвещенийДляОтправки.Количество() = 0 Тогда
		// все извещения уже созданы
		СписокParentEntityIdВсехИзвещений = ПолучитьСписокParentEntityIdВсехИзвещений(РезультатПолученияMessage.Значение);
		ЗаписатьДопРеквизитыСообщенияInvoiceReceiptIdСервер(РезультатПолученияMessage.Значение, СписокParentEntityIdВсехИзвещений, СообщениеСсылка);
		Возврат;
	КонецЕсли;
	
	Receipts = Новый Массив;
	
	Signer = Новый Структура;
	Signer.Вставить("SignerCertificateThumbprint", ДанныеАвторизации.Отпечаток);
	
	Для каждого Эл Из СписокParentEntityIdИзвещенийДляОтправки Цикл
		
		РезультатСозданияИзвещения = GenerateInvoiceDocumentReceiptXml(boxId, messageId, Эл.Значение, ЗаписатьJSONВызовСервера(Signer), ДанныеАвторизации);	
		
		Если РезультатСозданияИзвещения.Успешно Тогда
			
			ПутьКФайлу = СохранитьТекстИзвещенияВФайл(Эл.Значение, РезультатСозданияИзвещения.Значение);
			РезультатПодписанияИзвещения = ПолучитьПодписьФайлаДокумента(ПутьКФайлу, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.ПарольКонтейнера);
			
			Если РезультатПодписанияИзвещения.Успешно Тогда
				
				SignedContent = Новый Структура;
				ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКФайлу);
				SignedContent.Вставить("Content", 	Base64Строка(ДвоичныеДанные));
				SignedContent.Вставить("Signature", РезультатПодписанияИзвещения.ШифрованнаяПодпись);
				
				ReceiptAttachment = Новый Структура;
				ReceiptAttachment.Вставить("ParentEntityId", 	Эл.Значение);
				ReceiptAttachment.Вставить("SignedContent",		SignedContent);
				
				Receipts.Добавить(ReceiptAttachment);
			Иначе
				СП = Новый СообщениеПользователю;
				СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
				СП.Текст = "Не удалось подписать извещения по причине: " + РезультатПодписанияИзвещения.ОписаниеОшибки;
				СП.Сообщить();
			КонецЕсли;
			
			УдалитьФайлы(ПутьКФайлу);
		Иначе
			СП = Новый СообщениеПользователю;
			СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
			СП.Текст = "Не удалось сформировать извещения по причине: " + РезультатСозданияИзвещения.ОписаниеОшибки;
			СП.Сообщить();
		КонецЕсли;
		
	КонецЦикла;
	
	Если Receipts.Количество() = 0 Тогда
		// не смогли создать/подписать извещения                                   
		Возврат;
	КонецЕсли;
	
	MessagePatchToPost = Новый Структура;
	MessagePatchToPost.Вставить("BoxId", 		boxId);
	MessagePatchToPost.Вставить("MessageId", 	messageId);
	MessagePatchToPost.Вставить("Receipts", 	Receipts);
	
	РезультатОтправки = PostMessagePatch(ЗаписатьJSONВызовСервера(MessagePatchToPost),, ДанныеАвторизации);
	Если РезультатОтправки.Успешно Тогда
		ЗаписатьДопРеквизитыСообщенияInvoiceReceiptIdСервер(РезультатОтправки.Значение, СписокParentEntityIdИзвещенийДляОтправки, СообщениеСсылка);
	Иначе
		СП = Новый СообщениеПользователю;
		СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
		СП.Текст = "Не удалось отправить извещения по причине: " + РезультатОтправки.ОписаниеОшибки;
		СП.Сообщить();
		Возврат;
	КонецЕсли;
	
КонецПроцедуры // СформироватьИОтправитьИзвещенияОПолучении()

&НаКлиенте
Функция GenerateInvoiceDocumentReceiptXml(boxId, messageId, attachmentId, RequestBody, ДанныеАвторизации) 
	
	ПараметрыСтрокиЗапроса = "BoxId=" + boxId + "&messageId=" + messageId + "&attachmentId=" + attachmentId;
	ТипыДанных = Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "Строка");
	
	Возврат ВызватьМетодAPI("/GenerateInvoiceDocumentReceiptXml", ПараметрыСтрокиЗапроса, "POST", "", RequestBody, ДанныеАвторизации, ТипыДанных);
	
КонецФункции

&НаКлиенте
Функция PostMessagePatch(RequestBody, operationId = "", ДанныеАвторизации) 
	
	ПараметрыСтрокиЗапроса = "";
	Если Не ПустаяСтрока(operationId) Тогда
		ПараметрыСтрокиЗапроса = ПараметрыСтрокиЗапроса + "operationId=" + operationId;
	КонецЕсли;
	ТипыДанных = Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "Строка");
	
	Результат = ВызватьМетодAPI("/V3/PostMessagePatch", ПараметрыСтрокиЗапроса, "POST", "", RequestBody, ДанныеАвторизации, ТипыДанных);
	Если Не Результат.Успешно Тогда
		Возврат Результат;
	КонецЕсли;
	
	Результат.Значение = DoParseВызовСервера(Результат.Значение);
	Возврат Результат;		
	
КонецФункции

&НаКлиенте
Функция ПолучитьСписокParentEntityIdВсехИзвещений(Message)
	
	// могут быть AttachmentType: InvoiceConfirmation, InvoiceCorrectionRequest
	СписокParentEntityId = Новый СписокЗначений;
	
	Для каждого Entity Из Message.Entities Цикл
		Если Entity.AttachmentType = "InvoiceConfirmation"
			ИЛИ Entity.AttachmentType = "InvoiceCorrectionRequest" Тогда
			СписокParentEntityId.Добавить(Entity.EntityId, Entity.AttachmentType);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокParentEntityId;
	
КонецФункции // ПолучитьСписокParentEntityIdВсехИзвещений()

&НаКлиенте
Функция ПолучитьСписокParentEntityIdИзвещенийДляОтправки(Message)
	
	// могут быть AttachmentType: InvoiceConfirmation, InvoiceCorrectionRequest
	СписокParentEntityId = ПолучитьСписокParentEntityIdВсехИзвещений(Message);
	
	Для каждого Entity Из Message.Entities Цикл
		Если Entity.AttachmentType = "InvoiceReceipt" Тогда
			НайденныйЭлемент = СписокParentEntityId.НайтиПоЗначению(Entity.ParentEntityId);
			Если НЕ НайденныйЭлемент = Неопределено Тогда
				СписокParentEntityId.Удалить(НайденныйЭлемент);	
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокParentEntityId;
	
КонецФункции // ПолучитьСписокParentEntityIdИзвещенийДляОтправки()

&НаКлиенте
Функция СохранитьТекстИзвещенияВФайл(entityId, ТекстИзвещения)
	
	ПутьКФайлу = мРабочийКаталог + entityId;
	ВременныйФайл = Новый Файл(ПутьКФайлу);
	Если ВременныйФайл.Существует() Тогда
		УдалитьФайлы(ВременныйФайл.ПолноеИмя); //Если такой файл уже есть в temp, значит, он остался от предыдущей сессии, когда чо-то пошло не так. Удалим его.
	КонецЕсли;
	ТД = Новый ТекстовыйДокумент;
	ТД.УстановитьТекст(ТекстИзвещения);
	ТД.Записать(ПутьКФайлу, "windows-1251");
	
	Возврат ПутьКФайлу
	
КонецФункции

&НаСервере
Процедура ЗаписатьДопРеквизитыСообщенияInvoiceReceiptIdСервер(MessagePatch, СписокParentEntityId, СообщениеСсылка)
	
	Для каждого Entity Из MessagePatch.Entities Цикл
		Если Entity.AttachmentType = "InvoiceReceipt" Тогда
			
			НайденныйЭлемент = СписокParentEntityId.НайтиПоЗначению(Entity.ParentEntityId);
			Если НЕ НайденныйЭлемент = Неопределено Тогда
				МодульОбъекта().ЗаписатьДопРеквизитСправочника_КонтурEDI(СообщениеСсылка, "InvoiceReceiptEntityId_On" + НайденныйЭлемент.Представление, Entity.EntityId);
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;		
	
КонецПроцедуры


//-------------------------------------------------------------------------------------------------
// Все, что относится к патчу черновиков методом PrepareDocumentsToSign
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Функция PrepareDocumentsToSign(RequestBody, operationId = "", ДанныеАвторизации)     //патч для черновиков
	
	ПараметрыСтрокиЗапроса = "";
	Если Не ПустаяСтрока(operationId) Тогда
		ПараметрыСтрокиЗапроса = ПараметрыСтрокиЗапроса + "operationId=" + operationId;
	КонецЕсли;
	ТипыДанных = Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "Строка");
	
	Результат = ВызватьМетодAPI("/PrepareDocumentsToSign", ПараметрыСтрокиЗапроса, "POST", "", RequestBody, ДанныеАвторизации, ТипыДанных);
	
	Если Результат.Успешно = Истина Тогда
		Результат.Значение = DoParseВызовСервера(Результат.Значение);
	Иначе	
		Результат.ОписаниеОшибки = Результат.Значение;
	КонецЕсли;
	
	Возврат Результат;	
	
КонецФункции

&НаКлиенте
Функция ВыполнитьPrepareDocumentsToSign(PrepareDocumentsToSignRequest, ДанныеАвторизации)
	
	Результат = PrepareDocumentsToSign(ЗаписатьJSONВызовСервера(PrepareDocumentsToSignRequest), "", ДанныеАвторизации);
	
	Если Не Результат.Успешно Тогда
		ТекстОшибки = "Не удалось заполнить подписанта в документе." + Символы.ПС + 
		"Необходимо заполнить раздел ""Сертификаты и полномочия"" в настройках сотрудника в Диадоке, перейти по ссылке:" +
		Символы.ПС + "https://diadoc.kontur.ru/" + PrepareDocumentsToSignRequest.BoxId + "/EmployeesList";
		СП = Новый СообщениеПользователю;
		СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
		СП.Текст = ТекстОшибки;
		СП.Сообщить();
		
		СП = Новый СообщениеПользователю;
		СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
		СП.Текст = Результат.ОписаниеОшибки;
		СП.Сообщить();
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат.Значение;		
	
КонецФункции

&НаКлиенте
Функция НайтиPatchedEntity(PatchedEntities, EntityId)

	Entity = Неопределено;
	
	Для каждого PatchedEntity Из PatchedEntities Цикл
		Если PatchedEntity.DocumentId.EntityId = EntityId Тогда
			Entity = PatchedEntity;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
    Возврат Entity;
	
КонецФункции

&НаКлиенте
Функция ПодписатьPatchedEntity(PatchedEntity, МассивСтруктур, ДанныеАвторизации)
	
	Результат = ИнициализироватьСтруктуруРезультатаФункции();
	
	ПутьКФайлу = мРабочийКаталог + PatchedEntity.DocumentId.EntityId;
	ВременныйФайл = Новый Файл(ПутьКФайлу);
	Если ВременныйФайл.Существует() Тогда
		УдалитьФайлы(ВременныйФайл.ПолноеИмя); //Если такой файл уже есть в temp, значит, он остался от предыдущей сессии, когда чо-то пошло не так. Удалим его.
	КонецЕсли;
	Base64Значение(PatchedEntity.Content).Записать(ПутьКФайлу);

	РезультатПодписания = ПолучитьПодписьФайлаДокумента(ПутьКФайлу, ДанныеАвторизации.Отпечаток, ДанныеАвторизации.ПарольКонтейнера);
	
	Если Не РезультатПодписания.Успешно Тогда
		Результат.ОписаниеОшибки = РезультатПодписания.ОписаниеОшибки;
		Возврат Результат;
	Иначе
		Результат.Успешно = Истина;
	КонецЕсли;
	
	Signature = РезультатПодписания.ШифрованнаяПодпись;

	DocumentSignature = Новый Структура;
	DocumentSignature.Вставить("ParentEntityId", 	PatchedEntity.DocumentId.EntityId);
	DocumentSignature.Вставить("Signature",			Signature);
	DocumentSignature.Вставить("PatchedContentId",	PatchedEntity.PatchedContentId);
	
	МассивСтруктур.Добавить(DocumentSignature);

	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПолучитьEntitiesДляПодписания(MessageЧерновик)
	
	EntitiesДляПодписания = Новый Массив;
	
	Для каждого EntityЧерновика Из MessageЧерновик.Значение.Entities Цикл
		Если EntityЧерновика.Свойство("DocumentInfo") Тогда 
			EntitiesДляПодписания.Добавить(EntityЧерновика);
        КонецЕсли;
	КонецЦикла;
	
	Возврат EntitiesДляПодписания;
	
КонецФункции

&НаКлиенте
Функция ПолучитьPatchedEntities(EntitiesДляПатча, СчетФактураКПодписи, ДанныеАвторизации)
	
	PrepareDocumentsToSignRequest = Новый Структура;
	PrepareDocumentsToSignRequest.Вставить("BoxId", СчетФактураКПодписи.boxId);
    МассивDraftDocumentToPatch 	= Новый Массив;

	Для каждого Entity Из EntitiesДляПатча Цикл
		
		DocumentId = Новый Структура;
		DocumentId.Вставить("MessageId", 	СчетФактураКПодписи.messageId); 
		DocumentId.Вставить("EntityId",		Entity.EntityId);
		
		DraftDocumentToPatch = Новый Структура;
		DraftDocumentToPatch.Вставить("DocumentId", 	DocumentId);
		
		Если Найти(Entity.AttachmentType, "Universal") > 0
			ИЛИ (Entity.Свойство("AttachmentVersion") И Найти(Entity.AttachmentVersion, "Universal") > 0) Тогда
			МассивExtendedSigner = Новый Массив;
			
			ExtendedSigner = Новый Структура;
			ExtendedSigner.Вставить("BoxId",						СчетФактураКПодписи.boxId);
			ExtendedSigner.Вставить("SignerCertificateThumbprint",	ДанныеАвторизации.Отпечаток);
			
			МассивExtendedSigner.Добавить(ExtendedSigner);
			DraftDocumentToPatch.Вставить("ExtendedSigner",			МассивExtendedSigner);
		Иначе
			Signer = Новый Структура;
			Signer.Вставить("SignerCertificateThumbprint",			ДанныеАвторизации.Отпечаток);
			DraftDocumentToPatch.Вставить("Signer",					Signer);
		КонецЕсли;
		
		МассивDraftDocumentToPatch.Добавить(DraftDocumentToPatch);
	КонецЦикла;
	
	PrepareDocumentsToSignRequest.Вставить("DraftDocuments", 	МассивDraftDocumentToPatch);
	Результат = ВыполнитьPrepareDocumentsToSign(PrepareDocumentsToSignRequest, ДанныеАвторизации);	
	
	Если Результат = Неопределено Тогда
		Возврат Новый Массив;
	Иначе
		Возврат Результат.DocumentPatchedContents;
	КонецЕсли;
		
КонецФункции

//-------------------------------------------------------------------------------------------------
//обработка выполнения http-запросов  -------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Процедура ЗарегистрироватьОшибкуАвторизации(Организация,ОписаниеОшибки)

	//получить токен, повторно авторизовавшись

КонецПроцедуры // ЗарегистрироватьОшибкуАвторизации()

&НаКлиенте
Функция ОшибкаАвторизацииПоHttpКодуВозврата(ИмяРесурса,HttpКодВозврата)
	
	ОшибкаАвторизации = Ложь;
	Возврат "401"=HttpКодВозврата;
	
	//// по хорошему надо так:
	ПодготовитьТаблицуHttpКодовВозврата();
			
	Отбор = Новый Структура("ИмяРесурса,HttpКодВозврата",ИмяРесурса,HttpКодВозврата);
	МассивСтрок = HttpКодыВозвратаAPI.НайтиСтроки(Отбор);
	Если Не МассивСтрок.Количество() = 0 Тогда
		Строка = МассивСтрок[0];
		ОшибкаАвторизации = Строка.ОшибкаАвторизации;
	КонецЕсли;
	 
	Возврат ОшибкаАвторизации;
			
КонецФункции

&НаКлиенте
Процедура ДобавитьДанныеHttpКодаВозврата(Массив,ИмяРесурса,HttpКодВозврата,ОшибкаАвторизации,Описание)
	
	Данные = Новый Структура;
	Данные.Вставить("ИмяРесурса",		ИмяРесурса);
	Данные.Вставить("HttpКодВозврата",	HttpКодВозврата);
	Данные.Вставить("ОшибкаАвторизации",ОшибкаАвторизации);
	Данные.Вставить("Описание",			Описание);
	
	Массив.Добавить(Данные);
	
КонецПроцедуры

&НаКлиенте
Процедура ПодготовитьТаблицуHttpКодовВозврата()
	
	Если Не HttpКодыВозвратаAPI = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	HttpКодыВозвратаAPI = Новый Массив;
	
	// Authenticate
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке отсутствует параметр ddauth_api_client_id, или переданный в нем ключ разработчика не зарегистрирован в Диадоке");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/Authenticate",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// SendDraft
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	409,Ложь,  "попытка отправить дубликат сообщения, либо указан несуществующий идентификатор содержимого документа, подготовленного к отправке (см. PrepareDocumentsToSign), либо запрещен прием документов от контрагентов согласно свойству Sociability из Organization.");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/SendDraft",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// PrepareDocumentsToSign
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	400,Ложь,  "данные в запросе имеют неверный формат");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	403,Ложь,  "указанный в PrepareDocumentsToSignRequest.BoxId ящик не существует, либо у пользователя отсутствует доступ к ящику, либо у пользователя отсутствует доступ к документу");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/PrepareDocumentsToSign",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// GetMessage
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	404,Ложь,  "в указанном ящике нет сообщений с данным идентификатором");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/GetMessage",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// GetEntityContent
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	404,Ложь,  "в указанном ящике нет сообщения с идентификатором messageId, либо в указанном сообщении нет сущности с идентификатором entityId");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V4/GetEntityContent",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// PostMessagePatch
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	409,Ложь,  "попытка отправить дубликат сообщения или запрет приема документов от контрагентов согласно свойству Sociability из Organization");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/V3/PostMessagePatch",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
	// GenerateInvoiceDocumentReceiptXml
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	200,Ложь,  "операция успешно завершена");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	400,Ложь,  "данные в запросе имеют неверный формат или отсутствуют обязательные параметры");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	401,Истина,"в запросе отсутствует HTTP-заголовок Authorization, или в этом заголовке содержатся некорректные авторизационные данные");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	403,Ложь,  "доступ к ящику с предоставленным авторизационным токеном запрещен");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	404,Ложь,  "в указанном ящике нет сообщения с идентификатором messageId, либо в указанном сообщении нет сущности с идентификатором attachmentId");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	405,Ложь,  "используется неподходящий HTTP-метод");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	409,Ложь,  "формирование извещения о получении для данного документа невозможно");
	ДобавитьДанныеHttpКодаВозврата(HttpКодыВозвратаAPI,"/GenerateInvoiceDocumentReceiptXml",	500,Ложь,  "при обработке запроса возникла непредвиденная ошибка");
	
КонецПроцедуры

&НаКлиенте
Функция ОписаниеHttpКодаВозврата(ИмяРесурса,HttpКодВозврата)
	
	Описание = "";
	СтруктураHttpКодаВозврата = Неопределено;
	
	ПодготовитьТаблицуHttpКодовВозврата();
	
	Для Каждого Структура Из HttpКодыВозвратаAPI Цикл
		Если Не Структура.ИмяРесурса = ИмяРесурса или
			 Не Структура.HttpКодВозврата = HttpКодВозврата Тогда
			Продолжить;			
		КонецЕсли;
		СтруктураHttpКодаВозврата = Структура;
	КонецЦикла;
	
	Если Не СтруктураHttpКодаВозврата = Неопределено Тогда
		Описание = СтруктураHttpКодаВозврата.Описание;
	КонецЕсли;
	
	Возврат Описание;
	
КонецФункции
  
//-------------------------------------------------------------------------------------------------
//авторизация на сервере Диадока ------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Функция КлючАвторизацииAPI()
	
	Возврат "1S-Box2_19-b9b4602d-c9fa-4680-ad9a-0bd740eed1c8";
		
КонецФункции

&НаКлиенте
Функция ВыполнитьЗапросAPI(Соединение, ИмяРесурса, ПараметрыСтрокиЗапроса="" ,HttpЗаголовки, Метод, ТелоЗапроса="", ТипыДанных)
	
	Результат = Новый Структура("Успешно,Значение,HttpКодВозврата,ОписаниеОшибки",Ложь,Неопределено,500,"");
	
	ПолныйАдрес = ИмяРесурса + ?(ПараметрыСтрокиЗапроса="","","?") + ПараметрыСтрокиЗапроса;
	
	ТипТелаЗапроса = ТипыДанных.ТипТелаЗапроса;
	ТипТелаОтвета = ТипыДанных.ТипТелаОтвета;
	
	АдресАпи = "https://diadoc-api.kontur.ru";
			    		
	Соединение.Open(Метод,АдресАпи+ПолныйАдрес,0);

	Для Каждого HttpЗаголовок Из HttpЗаголовки Цикл
		Соединение.SetRequestHeader(HttpЗаголовок.Ключ, HttpЗаголовок.Значение);
	КонецЦикла;
	
	Если ТипТелаЗапроса = "ПутьКФайлу" Тогда
		Соединение.Send(BinaryStream(ТелоЗапроса));
	ИначеЕсли ТипТелаЗапроса = "Строка" Тогда
		Соединение.Send(ТелоЗапроса);		
	КонецЕсли;
	
	HttpКодВозврата = Соединение.status;
	Если ТипТелаОтвета = "ДвоичныеДанные" Тогда               
		Значение = Соединение.ResponseBody;
	ИначеЕсли ТипТелаОтвета = "Строка" Тогда
		Значение = Соединение.ResponseText();
	КонецЕсли;
	
	Результат.Успешно = (HttpКодВозврата = 200);
	Результат.Значение = Значение;
	Результат.HttpКодВозврата = HttpКодВозврата;
	Результат.ОписаниеОшибки = ОписаниеHttpКодаВозврата(ИмяРесурса,HttpКодВозврата);
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция Токен(ДанныеАвторизации, ИспользоватьКэш = Истина) Экспорт
	
    Токен = Неопределено;
	
	Если ДанныеАвторизации.ТипАвторизации = "ЛогинПароль" Тогда
		Ключ = ДанныеАвторизации.ЛогинДД;		
	ИначеЕсли ДанныеАвторизации.ТипАвторизации = "Сертификат" Тогда
		Ключ = ДанныеАвторизации.Отпечаток;	
	КонецЕсли;
	
	Если Токены = Неопределено Тогда
		Токены = Новый Соответствие;
	КонецЕсли;
	
	Если ИспользоватьКэш Тогда	
		//Токены = ИзвлечьИзВХ("Токены"); 
		Если Не Токены = Неопределено Тогда
			Токен = Токены.Получить(Ключ);
		КонецЕсли;
	КонецЕсли;
		
	Если Токен = Неопределено Тогда
		
		Состояние("Авторизация в Диадоке...");
		
		Токен					= "";
		ПараметрыСтрокиЗапроса	= "";
		ТелоЗапроса 			= "";
		ИмяРесурса				= "/Authenticate";
		Если ДанныеАвторизации.ТипАвторизации = "ЛогинПароль" Тогда //авторизация по логину/паролю
			ПараметрыСтрокиЗапроса = "login=" + ДанныеАвторизации.ЛогинДД + "&password=" + ДанныеАвторизации.ПарольДД;
			ТипыДанных 	= Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "Строка");
		ИначеЕсли ДанныеАвторизации.ТипАвторизации = "Сертификат" Тогда //авторизация по сертификату
		
			Если ИспользоватьCapicom Тогда
				ТелоЗапроса = ПолучитьСертификатCapicom(ДанныеАвторизации.Отпечаток,0);
			Иначе
				ТелоЗапроса = ПолучитьСертификат1СПоОтпечатку(ДанныеАвторизации.Отпечаток, Истина);
            КонецЕсли;
			ТипыДанных 	= Новый Структура("ТипТелаЗапроса,ТипТелаОтвета", "Строка", "ДвоичныеДанные");
		КонецЕсли;
		
		Если ТелоЗапроса = Неопределено Тогда 
			СП = Новый СообщениеПользователю;
			СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
			СП.Текст = "Не удалось получить сертификат!";
			СП.Сообщить();
			Возврат Неопределено;
		КонецЕсли;
		
		HttpЗаголовки = Новый Соответствие;
		HttpЗаголовки.Вставить("Authorization","DiadocAuth ddauth_api_client_id="+КлючАвторизацииAPI());// konturediauth_login="""+УчетнаяЗапись.Логин+""" , konturediauth_password="""+УчетнаяЗапись.Пароль+"""";
						
		Попытка
			РезультатВыполнения = ВыполнитьЗапросAPI(СоединениеДД(), ИмяРесурса, ПараметрыСтрокиЗапроса, HttpЗаголовки, "POST", ТелоЗапроса, ТипыДанных);
		Исключение
			_ОписаниеОшибки = ОписаниеОшибки();
			ТекстОшибки = "Не удалось выполнить запрос " + ИмяРесурса + " на клиенте: " + _ОписаниеОшибки;
			СП = Новый СообщениеПользователю;
			СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
			СП.Текст = ТекстОшибки;
			СП.Сообщить();
			Возврат Неопределено;
		КонецПопытки;
		Если Не РезультатВыполнения.Успешно Тогда
			ТекстОшибки = "Запрос " + ИмяРесурса + " выполнен на клиенте с ошибкой: " + РезультатВыполнения.ОписаниеОшибки;
			СП = Новый СообщениеПользователю;
			СП.ИдентификаторНазначения = Новый УникальныйИдентификатор(Параметры.IDОсновнойФормы);
			СП.Текст = ТекстОшибки;
			СП.Сообщить();
			Возврат Неопределено;		
		КонецЕсли;
				
		Если ТипыДанных.ТипТелаОтвета = "ДвоичныеДанные" Тогда 
			Токен = РасшифроватьЗашифрованныйТокен(РезультатВыполнения.Значение, ДанныеАвторизации.ПарольКонтейнера); //расшифруем ответ сервера закрытым ключом из контейнера	
        ИначеЕсли ТипыДанных.ТипТелаОтвета = "Строка" Тогда
			Токен = РезультатВыполнения.Значение;
		КонецЕсли;
		
		//Если Токены = Неопределено Тогда
		//	Токены = ИзвлечьИзВХ("Токены");
		//КонецЕсли;
		//Если Токены = Неопределено Тогда
		//	Токены = Новый Соответствие;
		//КонецЕсли;
		Токены.Вставить(Ключ, Токен);
		//ПоместитьВоВХ("Токены", Токены);
		
	КонецЕсли;
	
	Возврат Токен;
	
КонецФункции


//-------------------------------------------------------------------------------------------------
//криптография ------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаСервере
Функция ПолучитьПарольКонтейнераСертификатаСервер(Организация, Отпечаток)

	Возврат МодульОбъекта().ПолучитьПарольКонтейнераСертификата(Организация, Отпечаток);
	
КонецФункции // ПолучитьПарольКонтейнераСертификатаСервер()

&НаСервере
Процедура СохранитьПарольКонтейнераСертификатаСервер(Организация, Отпечаток, СертификатДействуетПо, ПарольКонтейнера)

	МодульОбъекта().СохранитьПарольКонтейнераСертификата(Организация, Отпечаток, СертификатДействуетПо, ПарольКонтейнера);
	
КонецПроцедуры // СохранитьПарольКонтейнераСертификатаСервер()

&НаКлиенте
Функция МенеджерКриптографии1С(ПарольКонтейнера = "")
	
	Если МенеджерКриптографии1С <> Неопределено 
		И МенеджерКриптографии1С.ПарольДоступаКЗакрытомуКлючу = ПарольКонтейнера Тогда
		Возврат МенеджерКриптографии1С;	
	КонецЕсли;
	
	Попытка
		МенеджерКриптографии1С = Новый МенеджерКриптографии("","",75);
		Если ПарольКонтейнера <> "" Тогда
			МенеджерКриптографии1С.ПарольДоступаКЗакрытомуКлючу = ПарольКонтейнера;
		КонецЕсли;
	Исключение
		_ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("Не удалось инициализировать менеджер криптографии 1С по причине:" +  Символы.ПС + _ИнформацияОбОшибке.Причина.Описание);
	КонецПопытки;

	Возврат МенеджерКриптографии1С;
	
КонецФункции

&НаКлиенте
Функция ШаблонРеквизитовСертификата()
	
	Структура = Новый Структура;
	Структура.Вставить("НаименованиеОрганизацииСубъекта","");
	Структура.Вставить("НаименованиеСубъекта","");
	Структура.Вставить("НачалоПериодаДействия",Дата(1,1,1));
	Структура.Вставить("ОкончаниеПериодаДействия",Дата(1,1,1));
	Структура.Вставить("НаименованиеУдостоверяющегоЦентра","");
	Структура.Вставить("Отпечаток","");
	Структура.Вставить("Расположение","клиент"); // отличет от серверного метода
	Структура.Вставить("ПарольКонтейнера",""); 
	
	Возврат Структура;
	
КонецФункции

&НаКлиенте
Функция ПолучитьРеквизитыСертификата(Отпечаток) Экспорт
	
	РеквизитыСертификата = Неопределено;	
	
	Попытка 
		
		Если ИспользоватьCapicom Тогда
			
			КоллекцияСертификатовХранилища = ХранилищеСертификатовCapicom().Certificates;
			КоличествоСертификатовХранилища = КоллекцияСертификатовХранилища.Count;
			
			Для Индекс = 1 По КоличествоСертификатовХранилища Цикл
				
				Сертификат = КоллекцияСертификатовХранилища.Item(Индекс);
				Если Не Сертификат.Thumbprint = Отпечаток Тогда
					Продолжить;
				КонецЕсли;
				
				РеквизитыСертификата = ПолучитьРеквизитыCOMОбъектаСертификата(Сертификат);
				Прервать;
				
			КонецЦикла;
			
		Иначе
			
			Сертификат = ПолучитьСертификат1СПоОтпечатку(Отпечаток);
			РеквизитыСертификата = ПолучитьРеквизиты1ССертификата(Сертификат);

		КонецЕсли;

	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат РеквизитыСертификата;
	
КонецФункции

&НаКлиенте
Функция ПолучитьРеквизиты1ССертификата(Сертификат)
	
	РеквизитыСертификата = ШаблонРеквизитовСертификата();
	
	НаименованиеОрганизацииСубъекта	= "";
	Если Сертификат.Субъект.Свойство("O") Тогда
		НаименованиеОрганизацииСубъекта = Сертификат.Субъект.O;
	КонецЕсли;
	
	НаименованиеСубъекта = "";
	Если Сертификат.Субъект.Свойство("SN") 
		И Сертификат.Субъект.Свойство("GN") Тогда
		НаименованиеСубъекта = Сертификат.Субъект.SN + " " + Сертификат.Субъект.GN;
	ИначеЕсли Сертификат.Субъект.Свойство("SN") 
		И Сертификат.Субъект.Свойство("G") Тогда
		НаименованиеСубъекта = Сертификат.Субъект.SN + " " + Сертификат.Субъект.G;
	ИначеЕсли Сертификат.Субъект.Свойство("CN") Тогда
		НаименованиеСубъекта = Сертификат.Субъект.CN;
	КонецЕсли;
		
	НаименованиеУдостоверяющегоЦентра = ""; 
	Если Сертификат.Издатель.Свойство("O") Тогда
		НаименованиеУдостоверяющегоЦентра = Сертификат.Издатель.O;
	ИначеЕсли Сертификат.Издатель.Свойство("CN") Тогда
		НаименованиеУдостоверяющегоЦентра = Сертификат.Издатель.CN;
	КонецЕсли;
	
	РеквизитыСертификата.НаименованиеОрганизацииСубъекта 	= НаименованиеОрганизацииСубъекта;
	РеквизитыСертификата.НаименованиеСубъекта 				= НаименованиеСубъекта;
	РеквизитыСертификата.НачалоПериодаДействия 				= Сертификат.ДатаНачала;
	РеквизитыСертификата.ОкончаниеПериодаДействия 			= Сертификат.ДатаОкончания;
	РеквизитыСертификата.НаименованиеУдостоверяющегоЦентра 	= НаименованиеУдостоверяющегоЦентра;
	РеквизитыСертификата.Отпечаток 							= СтрЗаменить(Строка(Сертификат.Отпечаток), " ", "");
	
	Возврат РеквизитыСертификата;	
	
КонецФункции

&НаКлиенте
Функция МассивСертификатов(ТолькоДействующие = Истина) Экспорт
	
	// вернет массив действующих сертификатов
	МассивСертификатов = Новый Массив;
			
	Попытка 
		
		Если ИспользоватьCapicom Тогда
			
			КоллекцияСертификатовХранилища = ХранилищеСертификатовCapicom().Certificates;
			КоличествоСертификатовХранилища = КоллекцияСертификатовХранилища.Count;
			
			Для Индекс = 1 По КоличествоСертификатовХранилища Цикл
				Сертификат = КоллекцияСертификатовХранилища.Item(Индекс);
				
				Если ТолькоДействующие
					И КонецДня(Сертификат.ValidToDate()) < ТекущаяДата() Тогда
					Продолжить;
				КонецЕсли;
				
				РеквизитыСертификата = ПолучитьРеквизитыCOMОбъектаСертификата(Сертификат);
				МассивСертификатов.Добавить(РеквизитыСертификата);
			КонецЦикла;
			
		Иначе
			
			КоллекцияСертификатовХранилища = ХранилищеСертификатов1С().ПолучитьВсе();
			
			Для каждого Сертификат Из КоллекцияСертификатовХранилища Цикл
				Если ТолькоДействующие
					И КонецДня(Сертификат.ДатаОкончания) < ТекущаяДата() Тогда
					Продолжить;
				КонецЕсли;
				
				РеквизитыСертификата = ПолучитьРеквизиты1ССертификата(Сертификат);
				МассивСертификатов.Добавить(РеквизитыСертификата);
			КонецЦикла;
			
		КонецЕсли;

	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
		Возврат МассивСертификатов;
	КонецПопытки;
		
	Возврат МассивСертификатов;
	
КонецФункции

&НаКлиенте
Функция ПолучитьРеквизитыCOMОбъектаСертификата(COMОбъектСертификата)
	
	РеквизитыСертификата = ШаблонРеквизитовСертификата();
	
	МассивДанныхУЦ = РазложитьСтрокуВМассивСлов_КонтурСВ(COMОбъектСертификата.IssuerName,",");
	Для Каждого Элемент Из МассивДанныхУЦ Цикл
		Если Найти(Элемент,"O=")>0 Тогда 
			НаименованиеУдостоверяющегоЦентра = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Элемент,"O=",""),"""""","|"),"""",""),"|","""");
		КонецЕсли;
	КонецЦикла;
	
	НаименованиеСубъекта = "";
	НаименованиеОрганизацииСубъекта = "";
	МассивДанныхСубъекта = РазложитьСтрокуВМассивСлов_КонтурСВ(COMОбъектСертификата.SubjectName,",");
	Для Каждого Элемент Из МассивДанныхСубъекта Цикл
		Если Найти(Элемент,"CN=")>0 Тогда
			НаименованиеСубъекта = СтрЗаменить(Элемент,"CN=",""); 			
		ИначеЕсли Найти(Элемент,"O=")>0 Тогда 
			НаименованиеОрганизацииСубъекта = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Элемент,"O=",""),"""""","|"),"""",""),"|","""");
		КонецЕсли;
	КонецЦикла;
	
	РеквизитыСертификата.НаименованиеОрганизацииСубъекта = НаименованиеОрганизацииСубъекта;
	РеквизитыСертификата.НаименованиеСубъекта = НаименованиеСубъекта;
	РеквизитыСертификата.НачалоПериодаДействия = COMОбъектСертификата.ValidFromDate;
	РеквизитыСертификата.ОкончаниеПериодаДействия = COMОбъектСертификата.ValidToDate;
	РеквизитыСертификата.НаименованиеУдостоверяющегоЦентра = НаименованиеУдостоверяющегоЦентра;
	РеквизитыСертификата.Отпечаток = COMОбъектСертификата.Thumbprint;
	
	Возврат РеквизитыСертификата;	
		
КонецФункции

&НаКлиенте
Функция ПолучитьСертификатCapicom(Отпечаток, ЭкспортСертификата=0)
	
	Если КэшСертификатов = Неопределено Тогда
		КэшСертификатов = Новый Соответствие;
	КонецЕсли;
	
	ТекСертификат = КэшСертификатов.Получить(Отпечаток);
	Попытка
						
		ПолученныеСертификаты = ХранилищеСертификатовCapicom();
		Если ПолученныеСертификаты = неопределено Тогда
			Возврат неопределено;
		Иначе
			Если ЭкспортСертификата = 3 Тогда //возвращает сертификат
				ТекСертификат = ПолученныеСертификаты.Certificates.Find(0, Отпечаток).Item(1); //0 - CAPICOM_CERTIFICATE_FIND_SHA1_HASH
			Иначе //экспорт сертификата 0 - Base64, 1 - DER (двоичные данные)
				ТекСертификат = ПолученныеСертификаты.Certificates.Find(0, Отпечаток).Item(1).Export(ЭкспортСертификата); //0 - CAPICOM_CERTIFICATE_FIND_SHA1_HASH	
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ ТекСертификат = Неопределено Тогда
			КэшСертификатов.Вставить(Отпечаток, ТекСертификат);
		КонецЕсли;
	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат ТекСертификат;
	
КонецФункции

&НаКлиенте
Функция ПолучитьСертификат1СПоОтпечатку(Отпечаток, ЭкспортСертификата = Ложь)
	
	Если КэшСертификатов = Неопределено Тогда
		КэшСертификатов = Новый Соответствие;
	КонецЕсли;
	
	ТекСертификат = КэшСертификатов.Получить(Отпечаток);
	Если ТекСертификат = Неопределено Тогда
		
		ДвоичныеДанныеОтпечатка = ПреобразоватьСтрокуДанныхВДвоичныеДанные(Отпечаток);
		
		ТекСертификат = ХранилищеСертификатов1С().НайтиПоОтпечатку(ДвоичныеДанныеОтпечатка);
		Если НЕ ТекСертификат = Неопределено Тогда
			КэшСертификатов.Вставить(Отпечаток, ТекСертификат);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЭкспортСертификата = Ложь Тогда
		Возврат ТекСертификат;
	ИначеЕсли ЭкспортСертификата = Истина Тогда
		Возврат Base64Строка(ТекСертификат.Выгрузить());
	Иначе 
		Возврат Неопределено;
	КонецЕсли;
		
КонецФункции

&НаКлиенте
Функция РасшифроватьЗашифрованныйТокен(ЗашифрованныйТокен, ПарольКонтейнера)
	
	Токен = "";
	
	Попытка
		
		Если ИспользоватьCapicom Тогда
			
			Дешифратор = Новый COMОбъект("CAPICOM.EnvelopedData");
			Дешифратор.Decrypt(ЗашифрованныйТокен); //токен будет представлен массивом байт, прогоним его через перекодировщик.
			
			Перекодировщик = Новый COMОбъект("CAPICOM.Utilities");
			ТокенВСтроках = Перекодировщик.Base64Encode(Дешифратор.Content); //получим токен в строках Base64
			
		Иначе
			
			ДвоичныеДанные = COMSafeArrayToBinary(ЗашифрованныйТокен);
			РасшифрованныеДанные = МенеджерКриптографии1С(ПарольКонтейнера).Расшифровать(ДвоичныеДанные);
			ТокенВСтроках = Base64Строка(РасшифрованныеДанные);

		КонецЕсли;
		
		НомерСтроки = 1; //объединим все строки в одну
		ОчереднаяСтрока = СтрПолучитьСтроку(ТокенВСтроках,НомерСтроки);
		Пока ОчереднаяСтрока<>"" Цикл
			Токен = Токен + ОчереднаяСтрока;
			НомерСтроки = НомерСтроки + 1;
			ОчереднаяСтрока = СтрПолучитьСтроку(ТокенВСтроках,НомерСтроки);
		КонецЦикла;
		
	Исключение
		Токен = Неопределено;
	КонецПопытки;
	
	Возврат Токен;
	
КонецФункции

&НаКлиенте
Функция ХранилищеСертификатовCapicom()
	
	Если ТипЗнч(ХранилищеСертификатовКонтурСВ) = Тип("COMОбъект") Тогда
		Возврат ХранилищеСертификатовКонтурСВ;	
	КонецЕсли; 
	
	Попытка
		CAPICOM_MY_STORE = "My";
		CAPICOM_CURRENT_USER_STORE = 2;
		CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED = 2;
		CAPICOM_CERTIFICATE_FIND_SHA1_HASH = 0;
		
		ХранилищеСертификатовКонтурСВ = Новый COMОбъект("CAPICOM.Store");
		ХранилищеСертификатовКонтурСВ.Open(CAPICOM_CURRENT_USER_STORE, CAPICOM_MY_STORE, CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED);
	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
		Сообщить("Не удалось инициализировать локальное хранилице сертификатов (" + _ОписаниеОшибки + ").");
		Сообщить("Следует провести диагностику, перейдя по ссылке: https://help.kontur.ru/ и автоматически установить все предложенные элементы для работы с сертификатами");
		Сообщить("Также можно запустить установку необходимых объектов напрямую, используя: https://help.kontur.ru/content/components/capicom.exe");
	КонецПопытки;
	
	Возврат ХранилищеСертификатовКонтурСВ;	
		
КонецФункции

&НаКлиенте
Функция ХранилищеСертификатов1С()
	
	Если ХранилищеСертификатовКонтурСВ <> Неопределено Тогда
		Возврат ХранилищеСертификатовКонтурСВ;	
	КонецЕсли;
	
	Попытка
		ХранилищеСертификатовКонтурСВ = МенеджерКриптографии1С().ПолучитьХранилищеСертификатов(ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты);
	Исключение
		_ОписаниеОшибки = ОписаниеОшибки();
		Сообщить("Не удалось инициализировать локальное хранилице сертификатов (" + _ОписаниеОшибки + ").");
	КонецПопытки;
	
	Возврат ХранилищеСертификатовКонтурСВ;	
	
КонецФункции

&НаКлиенте
Функция СоединениеДД()
	
	Если ТипЗнч(СоединениеДД) = Тип("COMОбъект") Тогда
		Возврат СоединениеДД;
	КонецЕсли;
	
	Сервер = "diadoc-api.kontur.ru";
	Прокси = Неопределено;
	Порт = 443;
	ЗащищенноеСоединение = Истина;
	
	СоединениеДД = ПолучитьCOMОбъект("","Microsoft.XMLHTTP");
	
	Возврат СоединениеДД;
		
КонецФункции

//-------------------------------------------------------------------------------------------------
//вспомогательные методы --------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

&НаКлиенте
Функция ПреобразоватьСтрокуДанныхВДвоичныеДанные(СтрокаДанных)

	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку("<foo xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" 
	|xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" xsi:type=""xsd:hexBinary"">" + СтрокаДанных + "</foo>");
	ДвоичныеДанныеДокумента = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
	
	Возврат ДвоичныеДанныеДокумента;

КонецФункции // ПреобразоватьСтрокуДанныхВДвоичныеДанные()

&НаКлиенте
Функция РазложитьСтрокуВМассивСлов_КонтурСВ(Знач Строка, РазделителиСлов="")
	
	Слова = Новый Массив;
	
	Для Сч = 1 По СтрДлина(РазделителиСлов) Цикл
		Строка = СтрЗаменить(Строка,Сред(РазделителиСлов,Сч,1),Символы.ПС);
	КонецЦикла;
	
	Для Сч=1 По СтрЧислоСтрок(Строка) Цикл
		ТекСлово = СокрЛП(СтрПолучитьСтроку(Строка,Сч));
		Если ТекСлово<>"" Тогда
			Слова.Добавить(ТекСлово);
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат Слова;
	
КонецФункции

&НаКлиенте
Функция BinaryStream(ПутьКФайлу)
	
	Stream = Новый COMОбъект("ADODB.Stream");
    Stream.Type = 1;
    Stream.Open();
	Stream.LoadFromFile(ПутьКФайлу);
	Возврат Stream.Read();
	
КонецФункции

&НаКлиенте
Процедура ПоместитьВоВХ(Имя,Значение)
	
	ПоместитьВоВременноеХранилище(Значение, Объект.ПараметрыКлиентСервер.АдресаВХ[Имя]);
				
КонецПроцедуры

&НаКлиенте
Функция ИзвлечьИзВХ(Имя)
	
	АдресВХ = Объект.ПараметрыКлиентСервер.АдресаВХ[Имя];
	
	Если Не ЭтоАдресВременногоХранилища(АдресВХ) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПолучитьИзВременногоХранилища(АдресВХ);
			
КонецФункции

&НаКлиенте
Функция ОсновнаяФорма() Экспорт
	
	Если ЭтаФорма.ВладелецФормы = Неопределено Тогда
		Возврат Неопределено;
	Иначе
		Возврат ЭтаФорма.ВладелецФормы.ОсновнаяФорма();
	КонецЕсли;
    	
КонецФункции

&НаКлиенте
Функция МодульОбменКлиент()
	
	Возврат ЭтаФорма;
	
КонецФункции
